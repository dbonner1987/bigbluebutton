{"version":3,"sources":["meteor://ðŸ’»app/client/whiteboard_models/whiteboard_line.coffee"],"names":[],"mappings":"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","file":"/client/whiteboard_models/whiteboard_line.coffee.js","sourcesContent":["MAX_PATHS_IN_SEQUENCE = 30\n\n# A line in the whiteboard\n# Note: is used to draw lines from the pencil tool and from the line tool, this is why some\n# methods can receive different set of parameters.\n# TODO: Maybe this should be split in WhiteboardPathModel for the pencil and\n#       WhiteboardLineModel for the line tool\nclass @WhiteboardLineModel extends WhiteboardToolModel\n\n  constructor: (@paper) ->\n    super @paper\n\n    # the defintion of this shape, kept so we can redraw the shape whenever needed\n    # format: svg path, stroke color, thickness\n    @definition = [\"\", \"#000\", \"0px\"]\n\n  # Creates a line in the paper\n  # @param  {number} x         the x value of the line start point as a percentage of the original width\n  # @param  {number} y         the y value of the line start point as a percentage of the original height\n  # @param  {string} colour    the colour of the shape to be drawn\n  # @param  {number} thickness the thickness of the line to be drawn\n  make: (info) ->\n\n    if info?.points?\n      x = info.points[0]\n      y = info.points[1]\n      color = info.color\n      thickness = info.thickness\n\n      x1 = x * @gw + @xOffset\n      y1 = y * @gh + @yOffset\n      path = \"M\" + x1 + \" \" + y1 + \" L\" + x1 + \" \" + y1\n      pathPercent = \"M\" + x + \" \" + y + \" L\" + x + \" \" + y\n      @obj = @paper.path(path)\n      @obj.attr \"stroke\", formatColor(color)\n      @obj.attr \"stroke-width\", zoomStroke(formatThickness(thickness))\n      @obj.attr({\"stroke-linejoin\": \"round\"})\n      @obj.attr \"stroke-linecap\", \"round\"\n\n      @definition = [pathPercent, @obj.attrs[\"stroke\"], @obj.attrs[\"stroke-width\"]]\n\n    @obj\n\n  # Update the line dimensions\n  # @param  {number}  x1         1) the x of the first point\n  #                              2) the next x point to be added to the line\n  # @param  {number}  y1         1) the y of the first point\n  #                              2) the next y point to be added to the line\n  # @param  {number,boolean} x2  1) the x of the second point\n  #                              2) true if the line should be added to the current line,\n  #                                 false if it should replace the last point\n  # @param  {number}         y2  1) the y of the second point\n  #                              2) undefined\n  update: (info) ->\n\n    if info?.points?\n      x1 = info.points[0]\n      y1 = info.points[1]\n      x2 = info.points[2]\n      y2 = info.points[3]\n\n      if @obj?\n        path = @_buildPath(info.points)\n\n        @definition[0] = path\n\n        path = @_scaleLinePath(path, @gw, @gh, @xOffset, @yOffset)\n        @obj.attr path: path\n\n  # Draw a line on the paper\n  # @param  {number,string} x1 1) the x value of the first point\n  #                            2) the string path\n  # @param  {number,string} y1 1) the y value of the first point\n  #                            2) the colour\n  # @param  {number} x2        1) the x value of the second point\n  #                            2) the thickness\n  # @param  {number} y2        1) the y value of the second point\n  #                            2) undefined\n  # @param  {string} colour    1) the colour of the shape to be drawn\n  #                            2) undefined\n  # @param  {number} thickness 1) the thickness of the line to be drawn\n  #                            2) undefined\n  draw: (x1, y1, x2, y2, colour, thickness) ->\n\n    # if the drawing is from the pencil tool, it comes as a path first\n    # if _.isString(x1)\n    #   colour = y1\n    #   thickness = x2\n    #   path = x1\n\n    # # if the drawing is from the line tool, it comes with two points\n    # else\n    #   path = @_buildPath(points)\n\n    # line = @paper.path(@_scaleLinePath(path, @gw, @gh, @xOffset, @yOffset))\n    # line.attr Utils.strokeAndThickness(colour, thickness)\n    # line.attr({\"stroke-linejoin\": \"round\"})\n    # line\n\n  # When dragging for drawing lines starts\n  # @param  {number} x the x value of the cursor\n  # @param  {number} y the y value of the cursor\n  # TODO: moved here but not finished\n  dragOnStart: (x, y) ->\n    # # find the x and y values in relation to the whiteboard\n    # sx = (@paperWidth - @gw) / 2\n    # sy = (@paperHeight - @gh) / 2\n    # @lineX = x - @containerOffsetLeft - sx + @xOffset\n    # @lineY = y - @containerOffsetTop - sy + @yOffset\n    # values = [ @lineX / @paperWidth, @lineY / @paperHeight, @currentColour, @currentThickness ]\n    # globals.connection.emitMakeShape \"line\", values\n\n  # As line drawing drag continues\n  # @param  {number} dx the difference between the x value from _lineDragStart and now\n  # @param  {number} dy the difference between the y value from _lineDragStart and now\n  # @param  {number} x  the x value of the cursor\n  # @param  {number} y  the y value of the cursor\n  # TODO: moved here but not finished\n  dragOnMove: (dx, dy, x, y) ->\n    # sx = (@paperWidth - @gw) / 2\n    # sy = (@paperHeight - @gh) / 2\n    # [cx, cy] = @_currentSlideOffsets()\n    # # find the x and y values in relation to the whiteboard\n    # @cx2 = x - @containerOffsetLeft - sx + @xOffset\n    # @cy2 = y - @containerOffsetTop - sy + @yOffset\n    # if @shiftPressed\n    #   globals.connection.emitUpdateShape \"line\", [ @cx2 / @paperWidth, @cy2 / @paperHeight, false ]\n    # else\n    #   @currentPathCount++\n    #   if @currentPathCount < MAX_PATHS_IN_SEQUENCE\n    #     globals.connection.emitUpdateShape \"line\", [ @cx2 / @paperHeight, @cy2 / @paperHeight, true ]\n    #   else if @obj?\n    #     @currentPathCount = 0\n    #     # save the last path of the line\n    #     @obj.attrs.path.pop()\n    #     path = @obj.attrs.path.join(\" \")\n    #     @obj.attr path: (path + \"L\" + @lineX + \" \" + @lineY)\n\n    #     # scale the path appropriately before sending\n    #     pathStr = @obj.attrs.path.join(\",\")\n    #     globals.connection.emitPublishShape \"path\",\n    #       [ @_scaleLinePath(pathStr, 1 / @gw, 1 / @gh),\n    #         @currentColour, @currentThickness ]\n    #     globals.connection.emitMakeShape \"line\",\n    #       [ @lineX / @paperWidth, @lineY / @paperHeight, @currentColour, @currentThickness ]\n    #   @lineX = @cx2\n    #   @lineY = @cy2\n\n  # Drawing line has ended\n  # @param  {Event} e the mouse event\n  # TODO: moved here but not finished\n  dragOnEnd: (e) ->\n    # if @obj?\n    #   path = @obj.attrs.path\n    #   @obj = null # any late updates will be blocked by this\n    #   # scale the path appropriately before sending\n    #   globals.connection.emitPublishShape \"path\",\n    #     [ @_scaleLinePath(path.join(\",\"), 1 / @gw, 1 / @gh),\n    #       @currentColour, @currentThickness ]\n\n  _buildPath: (points) ->\n    path = \"\"\n\n    if points and points.length >= 2\n      path += \"M #{points[0]} #{points[1]}\"\n      i = 2\n\n      while i < points.length\n        path += \"L#{points[i]} #{points[i + 1]}\"\n        i += 2\n\n      path += \"Z\"\n      path\n\n  # Scales a path string to fit within a width and height of the new paper size\n  # @param  {number} w width of the shape as a percentage of the original width\n  # @param  {number} h height of the shape as a percentage of the original height\n  # @return {string}   the path string after being manipulated to new paper size\n  _scaleLinePath: (string, w, h, xOffset=0, yOffset=0) ->\n    path = null\n    points = string.match(/(\\d+[.]?\\d*)/g)\n    len = points.length\n    j = 0\n\n    # go through each point and multiply it by the new height and width\n    while j < len\n      if j isnt 0\n        path += \"L\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset)\n      else\n        path = \"M\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset)\n      j += 2\n    path\n"]}