{"version":3,"sources":["meteor://ðŸ’»app/packages/cfs_micro-queue/packages/cfs_micro-queue.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8G","file":"/packages/cfs_micro-queue.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                               //\n// packages/cfs:micro-queue/micro-queue.js                                                       //\n//                                                                                               //\n///////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                 //\n/** A basic LIFO or FIFO queue                                                                   // 1\n  * This is better than a simple array with pop/shift because shift is O(n)                      // 2\n  * and can become slow with a large array.                                                      // 3\n  * @method MicroQueue                                                                           // 4\n  * @constructor                                                                                 // 5\n  * @param {boolean} [lifo=false] Set true for `lifo`, default is `fifo`                         // 6\n  * This queue was build as the spinal basis for the [`PowerQueue`](#PowerQueue)                 // 7\n  * The interface is very basic and consists of:                                                 // 8\n  * `add`, `get`, `reset` Making it possible to write a custom micro-queue for                   // 9\n  * `PowerQueue`, such as a queue that is persisted into a database.                             // 10\n  *                                                                                              // 11\n  * Usage:                                                                                       // 12\n```js                                                                                            // 13\n  var foo = new MicroQueue(); // Basic FIFO queue                                                // 14\n  foo.add(1);                                                                                    // 15\n  foo.add(2);                                                                                    // 16\n  foo.add(3);                                                                                    // 17\n  for (var i = 0; i < foo.length(); i++) {                                                       // 18\n    console.log(foo.get());                                                                      // 19\n  }                                                                                              // 20\n```                                                                                              // 21\n  * The result should be: \"1, 2, 3\"                                                              // 22\n  */                                                                                             // 23\nMicroQueue = function(lifo) {                                                                    // 24\n  var self = this, first = 0, last = -1, list = [];                                              // 25\n                                                                                                 // 26\n  // The private reactive length property                                                        // 27\n  self._length = 0;                                                                              // 28\n  var _lengthDeps = new Deps.Dependency();                                                       // 29\n  var maxKey = 0;                                                                                // 30\n  /** @method MicroQueue.length                                                                  // 31\n    * @reactive                                                                                  // 32\n    * @returns {number} Length / number of items in queue                                        // 33\n    */                                                                                           // 34\n  self.length = function() {                                                                     // 35\n    _lengthDeps.depend();                                                                        // 36\n    return self._length;                                                                         // 37\n  };                                                                                             // 38\n                                                                                                 // 39\n  /** @method MicroQueue.insert Add item to the queue                                            // 40\n    * @param {any} value The item to add to the queue                                            // 41\n    */                                                                                           // 42\n  self.insert = function(key, value) {                                                           // 43\n    // Compare key with first/last depending on LIFO to determine if it should                   // 44\n    // be added in reverse order. We track the greatest key entered - if we insert               // 45\n    // a key lower than this we should add it the the opposite end of the queue                  // 46\n    // We are compensating for the true use of keys in micro-queue its not truly                 // 47\n    // ordered by keys but we do try to order just a bit without impacting performance too much. // 48\n    // Tasks can be cut off from the power-queue typically unordered since tasks                 // 49\n    // will often run async                                                                      // 50\n    if (key > maxKey) maxKey = key;                                                              // 51\n    // If the key is an older key then \"reinsert\" item into the queue                            // 52\n    if (key < maxKey && first > 0) {                                                             // 53\n      list[--first] = {key: key, value: value};                                                  // 54\n    } else {                                                                                     // 55\n      list[++last] = {key: key, value: value};                                                   // 56\n    }                                                                                            // 57\n    self._length++;                                                                              // 58\n    _lengthDeps.changed();                                                                       // 59\n  };                                                                                             // 60\n                                                                                                 // 61\n  /** @method MicroQueue.getFirstItem Get next item from queue                                   // 62\n    * @return {any} The item that was next in line                                               // 63\n    */                                                                                           // 64\n  self.getFirstItem = function() {                                                               // 65\n    var value;                                                                                   // 66\n    if (first > last)                                                                            // 67\n      return; // queue empty                                                                     // 68\n    if (lifo) {                                                                                  // 69\n      value = list[last].value;                                                                  // 70\n      delete list[last]; // help garbage collector                                               // 71\n      last--;                                                                                    // 72\n    } else {                                                                                     // 73\n      value = list[first].value;                                                                 // 74\n      delete list[first]; // help garbage collector                                              // 75\n      first++;                                                                                   // 76\n    }                                                                                            // 77\n    self._length--;                                                                              // 78\n    _lengthDeps.changed();                                                                       // 79\n    return value;                                                                                // 80\n  };                                                                                             // 81\n                                                                                                 // 82\n  /** @method MicroQueue.reset Reset the queue                                                   // 83\n    * This method will empty all data in the queue.                                              // 84\n    */                                                                                           // 85\n  self.reset = function() {                                                                      // 86\n    first = 0;                                                                                   // 87\n    last = -1;                                                                                   // 88\n    self._length = 0;                                                                            // 89\n    list = [];                                                                                   // 90\n    _lengthDeps.changed();                                                                       // 91\n  };                                                                                             // 92\n                                                                                                 // 93\n  self.forEach = function(f, noneReactive) {                                                     // 94\n    if (!noneReactive) _lengthDeps.depend();                                                     // 95\n    for (var i = first; i <= last; i++) {                                                        // 96\n      f(list[i].value, list[i].key, i);                                                          // 97\n    }                                                                                            // 98\n  };                                                                                             // 99\n                                                                                                 // 100\n  self.forEachReverse = function(f, noneReactive) {                                              // 101\n    if (!noneReactive) _lengthDeps.depend();                                                     // 102\n                                                                                                 // 103\n    for (var i = last; i >= first; i--) {                                                        // 104\n      f(list[i].value, list[i].key, i);                                                          // 105\n    }                                                                                            // 106\n  };                                                                                             // 107\n                                                                                                 // 108\n  self.remove = function(id) {                                                                   // 109\n    var newList = [];                                                                            // 110\n    var removed = 0;                                                                             // 111\n                                                                                                 // 112\n    self.forEach(function(value, key, i) {                                                       // 113\n      if (id === key) {                                                                          // 114\n        removed++;                                                                               // 115\n      } else {                                                                                   // 116\n        newList[i - removed] = {key: key, value: value};                                         // 117\n      }                                                                                          // 118\n    });                                                                                          // 119\n    last -= removed;                                                                             // 120\n    self._length -= removed;                                                                     // 121\n    list = newList;                                                                              // 122\n    _lengthDeps.changed();                                                                       // 123\n  };                                                                                             // 124\n                                                                                                 // 125\n  self.fetch = function(noneReactive) {                                                          // 126\n    var result = [];                                                                             // 127\n    self.forEach(function(value, key, i) {                                                       // 128\n      return result.push(value);                                                                 // 129\n    }, noneReactive);                                                                            // 130\n    return result;                                                                               // 131\n  };                                                                                             // 132\n};                                                                                               // 133\n                                                                                                 // 134\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}