{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nMeteor.startup(function() {\n  Meteor.log.info(\"server start\");\n  Meteor.WhiteboardCleanStatus.remove({});\n  clearUsersCollection();\n  clearChatCollection();\n  clearMeetingsCollection();\n  clearShapesCollection();\n  clearSlidesCollection();\n  clearPresentationsCollection();\n  clearPollCollection();\n  Meteor.redisPubSub = new Meteor.RedisPubSub(function() {\n    return Meteor.log.info(\"created pubsub\");\n  });\n  Meteor.myQueue = new PowerQueue({});\n  Meteor.myQueue.taskHandler = function(data, next, failures) {\n    var eventName, ref;\n    eventName = (ref = JSON.parse(data.jsonMsg)) != null ? ref.header.name : void 0;\n    if (failures > 0) {\n      return Meteor.log.error(\"got a failure on taskHandler \" + eventName + \" \" + failures);\n    } else {\n      return handleRedisMessage(data, function() {\n        var length, lengthString;\n        length = Meteor.myQueue.length();\n        lengthString = function() {\n          if (length > 0) {\n            return \"In the queue we have \" + length + \" event(s) to process.\";\n          } else {\n            return \"\";\n          }\n        };\n        Meteor.log.info(\"in callback after handleRedisMessage \" + eventName + \". \" + (lengthString()));\n        return next();\n      });\n    }\n  };\n  return this.handleRedisMessage = function(data, callback) {\n    var chatMessage, currentlyBeingRecorded, dbUser, duration, emojiStatus, eventName, heightRatio, i, intendedForRecording, isLocked, j, k, l, len, len1, len2, len3, len4, listOfMeetings, m, meetingId, meetingName, message, messageObject, newPresenterId, newSettings, newSlide, notLoggedEventTypes, oldSettings, page, pollObj, poll_id, presentation, presentationId, processMeeting, processUser, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref3, ref4, ref5, ref6, ref7, ref8, ref9, requesterId, set_emoji_time, shape, shapeId, slide, slideId, status, user, userId, userObj, users, validStatus, voiceConf, voiceUserObj, whiteboardId, widthRatio, x, xOffset, y, yOffset;\n    message = JSON.parse(data.jsonMsg);\n    meetingId = (ref = message.payload) != null ? ref.meeting_id : void 0;\n    notLoggedEventTypes = [\"keep_alive_reply\", \"page_resized_message\", \"presentation_page_resized_message\", \"presentation_cursor_updated_message\", \"get_presentation_info_reply\", \"get_chat_history_reply\", \"get_whiteboard_shapes_reply\", \"presentation_shared_message\", \"presentation_conversion_done_message\", \"presentation_conversion_progress_message\", \"presentation_page_generated_message\", \"BbbPubSubPongMessage\", \"bbb_apps_is_alive_message\", \"user_voice_talking_message\", \"meeting_state_message\", \"get_recording_status_reply\"];\n    eventName = message.header.name;\n    meetingId = (ref1 = message.payload) != null ? ref1.meeting_id : void 0;\n    if (!(((message != null ? message.header : void 0) != null) && (message.payload != null))) {\n      Meteor.log.error(\"ERROR!! No header or payload\");\n      callback();\n    }\n    if (ref2 = message.header.name, indexOf.call(notLoggedEventTypes, ref2) < 0) {\n      Meteor.log.info(\"redis incoming message  \" + eventName + \"  \", {\n        message: data.jsonMsg\n      });\n    }\n    if (((message != null ? message.header : void 0) != null) && (message.payload != null)) {\n      if (eventName === 'meeting_created_message') {\n        meetingName = message.payload.name;\n        intendedForRecording = message.payload.recorded;\n        voiceConf = message.payload.voice_conf;\n        duration = message.payload.duration;\n        return addMeetingToCollection(meetingId, meetingName, intendedForRecording, voiceConf, duration, callback);\n      } else if ((message.payload.user != null) && (eventName === 'user_left_voice_message' || eventName === 'user_joined_voice_message' || eventName === 'user_voice_talking_message' || eventName === 'user_voice_muted_message')) {\n        voiceUserObj = {\n          'web_userid': message.payload.user.voiceUser.web_userid,\n          'listen_only': message.payload.listen_only,\n          'talking': message.payload.user.voiceUser.talking,\n          'joined': message.payload.user.voiceUser.joined,\n          'locked': message.payload.user.voiceUser.locked,\n          'muted': message.payload.user.voiceUser.muted\n        };\n        return updateVoiceUser(meetingId, voiceUserObj, callback);\n      } else if (eventName === 'user_listening_only') {\n        voiceUserObj = {\n          'web_userid': message.payload.userid,\n          'listen_only': message.payload.listen_only\n        };\n        return updateVoiceUser(meetingId, voiceUserObj, callback);\n      } else if (eventName === 'get_all_meetings_reply') {\n        Meteor.log.info(\"Let's store some data for the running meetings so that when an HTML5 client joins everything is ready!\");\n        Meteor.log.info(JSON.stringify(message));\n        listOfMeetings = message.payload.meetings;\n        processMeeting = function() {\n          var meeting;\n          meeting = listOfMeetings.pop();\n          if (meeting != null) {\n            return addMeetingToCollection(meeting.meetingID, meeting.meetingName, meeting.recorded, meeting.voiceBridge, meeting.duration, processMeeting);\n          } else {\n            return callback();\n          }\n        };\n        return processMeeting();\n      } else if (eventName === 'user_joined_message') {\n        userObj = message.payload.user;\n        dbUser = Meteor.Users.findOne({\n          userId: userObj.userid,\n          meetingId: message.payload.meeting_id\n        });\n        if ((dbUser != null ? (ref3 = dbUser.user) != null ? ref3.connection_status : void 0 : void 0) === \"offline\" && ((ref4 = message.payload.user) != null ? ref4.phone_user : void 0)) {\n          Meteor.log.error(\"offline AND phone user\");\n          return callback();\n        } else {\n          if ((dbUser != null ? dbUser.clientType : void 0) === \"HTML5\") {\n            status = dbUser != null ? dbUser.validated : void 0;\n            Meteor.log.info(\"in user_joined_message the validStatus of the user was \" + status);\n            userObj.timeOfJoining = message.header.current_time;\n            return userJoined(meetingId, userObj, callback);\n          } else {\n            return userJoined(meetingId, userObj, callback);\n          }\n        }\n      } else if (eventName === 'get_users_reply' && message.payload.requester_id === 'nodeJSapp') {\n        users = message.payload.users;\n        processUser = function() {\n          var user;\n          user = users.pop();\n          if (user != null) {\n            user.timeOfJoining = message.header.current_time;\n            if (user.emoji_status !== 'none' && typeof user.emoji_status === 'string') {\n              console.log(\"3\");\n              user.set_emoji_time = new Date();\n              return userJoined(meetingId, user, processUser);\n            } else {\n              return userJoined(meetingId, user, processUser);\n            }\n          } else {\n            return callback();\n          }\n        };\n        return processUser();\n      } else if (eventName === 'validate_auth_token_reply') {\n        userId = message.payload.userid;\n        user = Meteor.Users.findOne({\n          userId: userId,\n          meetingId: meetingId\n        });\n        validStatus = message.payload.valid;\n        if ((user != null ? user.clientType : void 0) === \"HTML5\") {\n          return Meteor.Users.update({\n            userId: userId,\n            meetingId: message.payload.meeting_id\n          }, {\n            $set: {\n              validated: validStatus\n            }\n          }, function(err, numChanged) {\n            var funct;\n            if (numChanged.insertedId != null) {\n              funct = function(cbk) {\n                var ref5, val;\n                val = (ref5 = Meteor.Users.findOne({\n                  userId: userId,\n                  meetingId: message.payload.meeting_id\n                })) != null ? ref5.validated : void 0;\n                Meteor.log.info(\"user.validated for user \" + userId + \" in meeting \" + user.meetingId + \" just became \" + val);\n                return cbk();\n              };\n              return funct(callback);\n            } else {\n              return callback();\n            }\n          });\n        } else {\n          Meteor.log.info(\"a non-html5 user got validate_auth_token_reply.\");\n          return callback();\n        }\n      } else if (eventName === 'user_left_message') {\n        userId = (ref5 = message.payload.user) != null ? ref5.userid : void 0;\n        if ((userId != null) && (meetingId != null)) {\n          return markUserOffline(meetingId, userId, callback);\n        } else {\n          return callback();\n        }\n      } else if (eventName === 'presenter_assigned_message') {\n        newPresenterId = message.payload.new_presenter_id;\n        if (newPresenterId != null) {\n          Meteor.Users.update({\n            \"user.presenter\": true,\n            meetingId: meetingId\n          }, {\n            $set: {\n              \"user.presenter\": false\n            }\n          }, function(err, numUpdated) {\n            return Meteor.log.info(\" Updating old presenter numUpdated=\" + numUpdated + \", err=\" + err);\n          });\n          Meteor.Users.update({\n            \"user.userid\": newPresenterId,\n            meetingId: meetingId\n          }, {\n            $set: {\n              \"user.presenter\": true\n            }\n          }, function(err, numUpdated) {\n            return Meteor.log.info(\" Updating new presenter numUpdated=\" + numUpdated + \", err=\" + err);\n          });\n        }\n        return callback();\n      } else if (eventName === 'user_emoji_status_message') {\n        userId = message.payload.userid;\n        meetingId = message.payload.meeting_id;\n        emojiStatus = message.payload.emoji_status;\n        if ((userId != null) && (meetingId != null)) {\n          set_emoji_time = new Date();\n          Meteor.Users.update({\n            \"user.userid\": userId\n          }, {\n            $set: {\n              \"user.set_emoji_time\": set_emoji_time,\n              \"user.emoji_status\": emojiStatus\n            }\n          }, function(err, numUpdated) {\n            return Meteor.log.info(\" Updating emoji numUpdated=\" + numUpdated + \", err=\" + err);\n          });\n        }\n        return callback();\n      } else if (eventName === 'user_locked_message' || eventName === 'user_unlocked_message') {\n        userId = message.payload.userid;\n        isLocked = message.payload.locked;\n        setUserLockedStatus(meetingId, userId, isLocked);\n        return callback();\n      } else if (eventName === \"meeting_ended_message\" || eventName === \"meeting_destroyed_event\" || eventName === \"end_and_kick_all_message\" || eventName === \"disconnect_all_users_message\") {\n        Meteor.log.info(\"DESTROYING MEETING \" + meetingId);\n        return removeMeetingFromCollection(meetingId, callback);\n\n        /*\n         if Meteor.Meetings.findOne({meetingId: meetingId})?\n          count=Meteor.Users.find({meetingId: meetingId}).count()\n          Meteor.log.info \"there are #{count} users in the meeting\"\n          for user in Meteor.Users.find({meetingId: meetingId}).fetch()\n            markUserOffline meetingId, user.userId\n          #TODO should we clear the chat messages for that meeting?!\n          unless eventName is \"disconnect_all_users_message\"\n            removeMeetingFromCollection meetingId\n         */\n      } else if (eventName === \"get_chat_history_reply\" && message.payload.requester_id === \"nodeJSapp\") {\n        if (Meteor.Meetings.findOne({\n          MeetingId: message.payload.meeting_id\n        }) == null) {\n          ref6 = message.payload.chat_history;\n          for (i = 0, len = ref6.length; i < len; i++) {\n            chatMessage = ref6[i];\n            addChatToCollection(meetingId, chatMessage);\n          }\n        }\n        return callback();\n      } else if (eventName === \"send_public_chat_message\" || eventName === \"send_private_chat_message\") {\n        messageObject = message.payload.message;\n        messageObject.from_time = message.header.current_time;\n        addChatToCollection(meetingId, messageObject);\n        return callback();\n      } else if (eventName === \"presentation_shared_message\") {\n        presentationId = (ref7 = message.payload.presentation) != null ? ref7.id : void 0;\n        Meteor.Presentations.update({\n          \"presentation.current\": true,\n          meetingId: meetingId\n        }, {\n          $set: {\n            \"presentation.current\": false\n          }\n        });\n        removePresentationFromCollection(meetingId, presentationId);\n        addPresentationToCollection(meetingId, message.payload.presentation);\n        ref9 = (ref8 = message.payload.presentation) != null ? ref8.pages : void 0;\n        for (j = 0, len1 = ref9.length; j < len1; j++) {\n          slide = ref9[j];\n          addSlideToCollection(meetingId, (ref10 = message.payload.presentation) != null ? ref10.id : void 0, slide);\n          if (slide.current) {\n            displayThisSlide(meetingId, slide.id, slide);\n          }\n        }\n        return callback();\n      } else if (eventName === \"get_presentation_info_reply\" && message.payload.requester_id === \"nodeJSapp\") {\n        ref11 = message.payload.presentations;\n        for (k = 0, len2 = ref11.length; k < len2; k++) {\n          presentation = ref11[k];\n          addPresentationToCollection(meetingId, presentation);\n          ref12 = presentation.pages;\n          for (l = 0, len3 = ref12.length; l < len3; l++) {\n            page = ref12[l];\n            addSlideToCollection(meetingId, presentation.id, page);\n            whiteboardId = presentation.id + \"/\" + page.num;\n            message = {\n              \"payload\": {\n                \"meeting_id\": meetingId,\n                \"requester_id\": \"nodeJSapp\",\n                \"whiteboard_id\": whiteboardId\n              },\n              \"header\": {\n                \"timestamp\": new Date().getTime(),\n                \"name\": \"get_whiteboard_shapes_request\",\n                \"version\": \"0.0.1\"\n              }\n            };\n            if ((whiteboardId != null) && (meetingId != null)) {\n              publish(Meteor.config.redis.channels.toBBBApps.whiteboard, message);\n            } else {\n              Meteor.log.info(\"did not have enough information to send a user_leaving_request\");\n            }\n          }\n        }\n        return callback();\n      } else if (eventName === \"presentation_page_changed_message\") {\n        newSlide = message.payload.page;\n        displayThisSlide(meetingId, newSlide != null ? newSlide.id : void 0, newSlide);\n        return callback();\n      } else if (eventName === \"presentation_removed_message\") {\n        presentationId = message.payload.presentation_id;\n        meetingId = message.payload.meeting_id;\n        removePresentationFromCollection(meetingId, presentationId);\n        return callback();\n      } else if (eventName === \"get_whiteboard_shapes_reply\" && message.payload.requester_id === \"nodeJSapp\") {\n        if (Meteor.WhiteboardCleanStatus.findOne({\n          meetingId: meetingId\n        }) == null) {\n          Meteor.WhiteboardCleanStatus.insert({\n            meetingId: meetingId,\n            in_progress: false\n          });\n        }\n        ref13 = message.payload.shapes;\n        for (m = 0, len4 = ref13.length; m < len4; m++) {\n          shape = ref13[m];\n          whiteboardId = shape.wb_id;\n          addShapeToCollection(meetingId, whiteboardId, shape);\n        }\n        return callback();\n      } else if (eventName === \"send_whiteboard_shape_message\") {\n        if (message.payload.shape.shape_type === \"poll_result\" && typeof message.payload.shape.shape.result === 'string') {\n          message.payload.shape.shape.result = JSON.parse(message.payload.shape.shape.result);\n        }\n        shape = message.payload.shape;\n        whiteboardId = shape != null ? shape.wb_id : void 0;\n        addShapeToCollection(meetingId, whiteboardId, shape);\n        return callback();\n      } else if (eventName === \"presentation_cursor_updated_message\") {\n        x = message.payload.x_percent;\n        y = message.payload.y_percent;\n        Meteor.Presentations.update({\n          \"presentation.current\": true,\n          meetingId: meetingId\n        }, {\n          $set: {\n            \"pointer.x\": x,\n            \"pointer.y\": y\n          }\n        });\n        return callback();\n      } else if (eventName === \"whiteboard_cleared_message\") {\n        whiteboardId = message.payload.whiteboard_id;\n        Meteor.WhiteboardCleanStatus.update({\n          meetingId: meetingId\n        }, {\n          $set: {\n            'in_progress': true\n          }\n        });\n        removeAllShapesFromSlide(meetingId, whiteboardId);\n        return callback();\n      } else if (eventName === \"undo_whiteboard_request\") {\n        whiteboardId = message.payload.whiteboard_id;\n        shapeId = message.payload.shape_id;\n        removeShapeFromSlide(meetingId, whiteboardId, shapeId);\n        return callback();\n      } else if (eventName === \"presentation_page_resized_message\") {\n        slideId = (ref14 = message.payload.page) != null ? ref14.id : void 0;\n        heightRatio = (ref15 = message.payload.page) != null ? ref15.height_ratio : void 0;\n        widthRatio = (ref16 = message.payload.page) != null ? ref16.width_ratio : void 0;\n        xOffset = (ref17 = message.payload.page) != null ? ref17.x_offset : void 0;\n        yOffset = (ref18 = message.payload.page) != null ? ref18.y_offset : void 0;\n        presentationId = slideId.split(\"/\")[0];\n        Meteor.Slides.update({\n          presentationId: presentationId,\n          \"slide.current\": true\n        }, {\n          $set: {\n            \"slide.height_ratio\": heightRatio,\n            \"slide.width_ratio\": widthRatio,\n            \"slide.x_offset\": xOffset,\n            \"slide.y_offset\": yOffset\n          }\n        });\n        return callback();\n      } else if (eventName === \"recording_status_changed_message\") {\n        intendedForRecording = message.payload.recorded;\n        currentlyBeingRecorded = message.payload.recording;\n        Meteor.Meetings.update({\n          meetingId: meetingId,\n          intendedForRecording: intendedForRecording\n        }, {\n          $set: {\n            currentlyBeingRecorded: currentlyBeingRecorded\n          }\n        });\n        return callback();\n      } else if (eventName === \"eject_voice_user_message\") {\n        return callback();\n      } else if (eventName === \"new_permission_settings\") {\n        oldSettings = (ref19 = Meteor.Meetings.findOne({\n          meetingId: meetingId\n        })) != null ? ref19.roomLockSettings : void 0;\n        newSettings = (ref20 = message.payload) != null ? ref20.permissions : void 0;\n        if (!(oldSettings != null ? oldSettings.disableMic : void 0) && newSettings.disableMic) {\n          handleLockingMic(meetingId, newSettings);\n        }\n        Meteor.Meetings.update({\n          meetingId: meetingId\n        }, {\n          $set: {\n            'roomLockSettings.disablePrivateChat': newSettings.disablePrivateChat,\n            'roomLockSettings.disableCam': newSettings.disableCam,\n            'roomLockSettings.disableMic': newSettings.disableMic,\n            'roomLockSettings.lockOnJoin': newSettings.lockOnJoin,\n            'roomLockSettings.lockedLayout': newSettings.lockedLayout,\n            'roomLockSettings.disablePublicChat': newSettings.disablePublicChat,\n            'roomLockSettings.lockOnJoinConfigurable': newSettings.lockOnJoinConfigurable\n          }\n        });\n        return callback();\n      } else if (eventName === \"poll_started_message\") {\n        if ((message.payload.meeting_id != null) && (message.payload.requester_id != null) && (message.payload.poll != null)) {\n          if (Meteor.Meetings.findOne({\n            meetingId: message.payload.meeting_id\n          }) != null) {\n            users = Meteor.Users.find({\n              meetingId: message.payload.meeting_id\n            }, {\n              fields: {\n                \"user.userid\": 1,\n                _id: 0\n              }\n            }).fetch();\n            addPollToCollection(message.payload.poll, message.payload.requester_id, users, message.payload.meeting_id);\n          }\n        }\n        return callback();\n      } else if (eventName === \"poll_stopped_message\") {\n        meetingId = message.payload.meeting_id;\n        poll_id = message.payload.poll_id;\n        clearPollCollection(meetingId, poll_id);\n        return callback();\n      } else if (eventName === \"user_voted_poll_message\") {\n        if ((((ref21 = message.payload) != null ? ref21.poll : void 0) != null) && (message.payload.meeting_id != null) && (message.payload.presenter_id != null)) {\n          pollObj = message.payload.poll;\n          meetingId = message.payload.meeting_id;\n          requesterId = message.payload.presenter_id;\n          updatePollCollection(pollObj, meetingId, requesterId);\n          return callback();\n        }\n      } else if (eventName === \"poll_show_result_message\") {\n        if ((message.payload.poll.id != null) && (message.payload.meeting_id != null)) {\n          poll_id = message.payload.poll.id;\n          meetingId = message.payload.meeting_id;\n          clearPollCollection(meetingId, poll_id);\n        }\n        return callback();\n      } else {\n        if (indexOf.call(notLoggedEventTypes, eventName) < 0) {\n          Meteor.log.info(\"WARNING!!! THE JSON MESSAGE WAS NOT OF TYPE SUPPORTED BY THIS APPLICATION\\n \" + eventName + \"   {JSON.stringify message}\");\n        }\n        return callback();\n      }\n    } else {\n      return callback();\n    }\n  };\n});\n","sourceMap":{"version":3,"file":"/server/server.coffee.js","sourceRoot":"","sources":["/server/server.coffee"],"names":[],"mappings":"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","sourcesContent":["Meteor.startup ->\r\n  Meteor.log.info \"server start\"\r\n\r\n  #remove all data\r\n  Meteor.WhiteboardCleanStatus.remove({})\r\n  clearUsersCollection()\r\n  clearChatCollection()\r\n  clearMeetingsCollection()\r\n  clearShapesCollection()\r\n  clearSlidesCollection()\r\n  clearPresentationsCollection()\r\n  clearPollCollection()\r\n\r\n  # create create a PubSub connection, start listening\r\n  Meteor.redisPubSub = new Meteor.RedisPubSub(->\r\n    Meteor.log.info \"created pubsub\")\r\n\r\n\r\n  Meteor.myQueue = new PowerQueue({\r\n    # autoStart:true\r\n    # isPaused: true\r\n  })\r\n  Meteor.myQueue.taskHandler = (data, next, failures) ->\r\n    eventName = JSON.parse(data.jsonMsg)?.header.name\r\n    if failures > 0\r\n      Meteor.log.error \"got a failure on taskHandler #{eventName} #{failures}\"\r\n    else\r\n      handleRedisMessage(data, ()->\r\n        length = Meteor.myQueue.length()\r\n        lengthString = ->\r\n          if length>0\r\n            \"In the queue we have #{length} event(s) to process.\"\r\n          else \"\"\r\n\r\n        Meteor.log.info \"in callback after handleRedisMessage #{eventName}.\r\n          #{lengthString()}\"\r\n        next()\r\n      )\r\n\r\n\r\n  # To ensure that we process the redis json event messages serially we use a\r\n  # callback. This callback is to be called when the Meteor collection is\r\n  # updated with the information coming in the payload of the json message. The\r\n  # callback signalizes to the queue that we are done processing the current\r\n  # message in the queue and are ready to move on to the next one. If we do not\r\n  # use the callback mechanism we may encounter a race condition situation\r\n  # due to not following the order of events coming through the redis pubsub.\r\n  # for example: a user_left event reaching the collection before a user_joined\r\n  # for the same user.\r\n  @handleRedisMessage = (data, callback) ->\r\n    message = JSON.parse(data.jsonMsg)\r\n    # correlationId = message.payload?.reply_to or message.header?.reply_to\r\n    meetingId = message.payload?.meeting_id\r\n\r\n    # Avoid cluttering the log with json messages carrying little or repetitive\r\n    # information. Comment out a message type in the array to be able to see it\r\n    # in the log upon restarting of the Meteor process.\r\n    notLoggedEventTypes = [\r\n      \"keep_alive_reply\"\r\n      \"page_resized_message\"\r\n      \"presentation_page_resized_message\"\r\n      \"presentation_cursor_updated_message\"\r\n      \"get_presentation_info_reply\"\r\n#      \"get_users_reply\"\r\n      \"get_chat_history_reply\"\r\n#      \"get_all_meetings_reply\"\r\n      \"get_whiteboard_shapes_reply\"\r\n      \"presentation_shared_message\"\r\n      \"presentation_conversion_done_message\"\r\n      \"presentation_conversion_progress_message\"\r\n      \"presentation_page_generated_message\"\r\n      # \"presentation_page_changed_message\"\r\n      \"BbbPubSubPongMessage\"\r\n      \"bbb_apps_is_alive_message\"\r\n      \"user_voice_talking_message\"\r\n      \"meeting_state_message\"\r\n      \"get_recording_status_reply\"\r\n    ]\r\n\r\n    eventName = message.header.name\r\n    meetingId = message.payload?.meeting_id\r\n\r\n    unless message?.header? and message.payload?\r\n      Meteor.log.error \"ERROR!! No header or payload\"\r\n      callback()\r\n\r\n    unless message.header.name in notLoggedEventTypes\r\n      Meteor.log.info \"redis incoming message  #{eventName}  \",\r\n        message: data.jsonMsg\r\n\r\n    # we currently disregard the pattern and channel\r\n    if message?.header? and message.payload?\r\n      if eventName is 'meeting_created_message'\r\n        # Meteor.log.error JSON.stringify message\r\n        meetingName = message.payload.name\r\n        intendedForRecording = message.payload.recorded\r\n        voiceConf = message.payload.voice_conf\r\n        duration = message.payload.duration\r\n        addMeetingToCollection meetingId, meetingName, intendedForRecording,\r\n         voiceConf, duration, callback\r\n\r\n      # handle voice events\r\n      else if message.payload.user? and eventName in [\r\n       'user_left_voice_message'\r\n       'user_joined_voice_message'\r\n       'user_voice_talking_message'\r\n       'user_voice_muted_message']\r\n\r\n        voiceUserObj = {\r\n          'web_userid': message.payload.user.voiceUser.web_userid\r\n          'listen_only': message.payload.listen_only\r\n          'talking': message.payload.user.voiceUser.talking\r\n          'joined': message.payload.user.voiceUser.joined\r\n          'locked': message.payload.user.voiceUser.locked\r\n          'muted': message.payload.user.voiceUser.muted\r\n        }\r\n        updateVoiceUser meetingId, voiceUserObj, callback\r\n\r\n      else if eventName is 'user_listening_only'\r\n        voiceUserObj = {\r\n          'web_userid': message.payload.userid\r\n          'listen_only': message.payload.listen_only\r\n        }\r\n        updateVoiceUser meetingId, voiceUserObj, callback\r\n\r\n      else if eventName is 'get_all_meetings_reply'\r\n        Meteor.log.info \"Let's store some data for the running meetings\r\n         so that when an HTML5 client joins everything is ready!\"\r\n        Meteor.log.info JSON.stringify(message)\r\n        listOfMeetings = message.payload.meetings\r\n\r\n        # Processing the meetings recursively with a callback to notify us,\r\n        # ensuring that we update the meeting collection serially\r\n        processMeeting = () ->\r\n          meeting = listOfMeetings.pop()\r\n          if meeting?\r\n            addMeetingToCollection meeting.meetingID, meeting.meetingName,\r\n              meeting.recorded, meeting.voiceBridge, meeting.duration, processMeeting\r\n          else\r\n            callback() # all meeting arrays (if any) have been processed\r\n\r\n        processMeeting()\r\n\r\n      else if eventName is 'user_joined_message'\r\n        userObj = message.payload.user\r\n        dbUser = Meteor.Users.findOne({userId: userObj.userid, meetingId: message.payload.meeting_id})\r\n\r\n        # On attempting reconnection of Flash clients (in voiceBridge) we receive\r\n        # an extra user_joined_message. Ignore it as it will add an extra user\r\n        # in the user list, creating discrepancy with the list in the Flash client\r\n        if dbUser?.user?.connection_status is \"offline\" and message.payload.user?.phone_user\r\n          Meteor.log.error \"offline AND phone user\"\r\n          callback() #return without joining the user\r\n        else\r\n          if dbUser?.clientType is \"HTML5\" # typically html5 users will be in\r\n            # the db [as a dummy user] before the joining message\r\n            status = dbUser?.validated\r\n            Meteor.log.info \"in user_joined_message the validStatus\r\n             of the user was #{status}\"\r\n            userObj.timeOfJoining = message.header.current_time\r\n            userJoined meetingId, userObj, callback\r\n          else\r\n            userJoined meetingId, userObj, callback\r\n\r\n\r\n      # only process if requester is nodeJSapp means only process in the case when\r\n      # we explicitly request the users\r\n      else if eventName is 'get_users_reply' and message.payload.requester_id is 'nodeJSapp'\r\n        users = message.payload.users\r\n\r\n        #TODO make the serialization be split per meeting. This will allow us to\r\n        # use N threads vs 1 and we'll take advantage of Mongo's concurrency tricks\r\n\r\n        # Processing the users recursively with a callback to notify us,\r\n        # ensuring that we update the users collection serially\r\n        processUser = () ->\r\n          user = users.pop()\r\n          if user?\r\n            user.timeOfJoining = message.header.current_time\r\n            if user.emoji_status isnt 'none' and typeof user.emoji_status is 'string'\r\n              console.log \"3\"\r\n              user.set_emoji_time = new Date()\r\n              userJoined meetingId, user, processUser\r\n            else\r\n              # console.error(\"this is not supposed to happen\")\r\n              userJoined meetingId, user, processUser\r\n          else\r\n            callback() # all meeting arrays (if any) have been processed\r\n\r\n        processUser()\r\n\r\n\r\n      else if eventName is 'validate_auth_token_reply'\r\n        userId = message.payload.userid\r\n        user = Meteor.Users.findOne({userId:userId, meetingId: meetingId})\r\n        validStatus = message.payload.valid\r\n\r\n        # if the user already exists in the db\r\n        if user?.clientType is \"HTML5\"\r\n          #if the html5 client user was validated successfully, add a flag\r\n          Meteor.Users.update({userId:userId, meetingId:message.payload.meeting_id},\r\n            {$set:{validated: validStatus}},\r\n            (err, numChanged) ->\r\n              if numChanged.insertedId?\r\n                funct = (cbk) ->\r\n                  val=Meteor.Users.findOne({userId:userId, meetingId: message.payload.meeting_id})?.validated\r\n                  Meteor.log.info \"user.validated for user #{userId} in meeting #{user.meetingId} just became #{val}\"\r\n                  cbk()\r\n\r\n                funct(callback)\r\n              else\r\n                callback()\r\n          )\r\n        else\r\n          Meteor.log.info \"a non-html5 user got validate_auth_token_reply.\"\r\n          callback()\r\n\r\n\r\n      else if eventName is 'user_left_message'\r\n        userId = message.payload.user?.userid\r\n        if userId? and meetingId?\r\n          markUserOffline meetingId, userId, callback\r\n        else\r\n          callback() #TODO check how to get these cases out and reuse code\r\n\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is 'presenter_assigned_message'\r\n        newPresenterId = message.payload.new_presenter_id\r\n        if newPresenterId?\r\n          # reset the previous presenter\r\n          Meteor.Users.update({\"user.presenter\": true, meetingId: meetingId},\r\n            {$set: {\"user.presenter\": false}},\r\n            (err, numUpdated) ->\r\n              Meteor.log.info(\" Updating old presenter numUpdated=#{numUpdated},\r\n               err=#{err}\")\r\n          )\r\n          # set the new presenter\r\n          Meteor.Users.update({\"user.userid\": newPresenterId, meetingId: meetingId},\r\n            {$set: {\"user.presenter\": true}},\r\n            (err, numUpdated) ->\r\n              Meteor.log.info(\" Updating new presenter numUpdated=#{numUpdated},\r\n               err=#{err}\")\r\n          )\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is 'user_emoji_status_message'\r\n        userId = message.payload.userid\r\n        meetingId = message.payload.meeting_id\r\n        emojiStatus = message.payload.emoji_status\r\n        if userId? and meetingId?\r\n          set_emoji_time = new Date()\r\n          Meteor.Users.update({\"user.userid\": userId},\r\n            {$set:{\"user.set_emoji_time\":set_emoji_time,\"user.emoji_status\":emojiStatus}},\r\n            (err, numUpdated) ->\r\n              Meteor.log.info(\" Updating emoji numUpdated=#{numUpdated}, err=#{err}\")\r\n          )\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName in ['user_locked_message', 'user_unlocked_message']\r\n        userId = message.payload.userid\r\n        isLocked = message.payload.locked\r\n        setUserLockedStatus(meetingId, userId, isLocked)\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName in [\"meeting_ended_message\", \"meeting_destroyed_event\",\r\n        \"end_and_kick_all_message\", \"disconnect_all_users_message\"]\r\n        Meteor.log.info(\"DESTROYING MEETING #{meetingId}\")\r\n        removeMeetingFromCollection meetingId, callback\r\n\r\n        ###\r\n         if Meteor.Meetings.findOne({meetingId: meetingId})?\r\n          count=Meteor.Users.find({meetingId: meetingId}).count()\r\n          Meteor.log.info \"there are #{count} users in the meeting\"\r\n          for user in Meteor.Users.find({meetingId: meetingId}).fetch()\r\n            markUserOffline meetingId, user.userId\r\n          #TODO should we clear the chat messages for that meeting?!\r\n          unless eventName is \"disconnect_all_users_message\"\r\n            removeMeetingFromCollection meetingId\r\n        ###\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"get_chat_history_reply\" and message.payload.requester_id is \"nodeJSapp\"\r\n        unless Meteor.Meetings.findOne({MeetingId: message.payload.meeting_id})?\r\n          for chatMessage in message.payload.chat_history\r\n            addChatToCollection meetingId, chatMessage\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"send_public_chat_message\" or eventName is \"send_private_chat_message\"\r\n        messageObject = message.payload.message\r\n        # use current_time instead of message.from_time so that the chats from Flash and HTML5 have uniform times\r\n        messageObject.from_time = message.header.current_time\r\n        addChatToCollection meetingId, messageObject\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"presentation_shared_message\"\r\n        presentationId = message.payload.presentation?.id\r\n        # change the currently displayed presentation to presentation.current = false\r\n        Meteor.Presentations.update({\"presentation.current\": true, meetingId: meetingId},\r\n          {$set: {\"presentation.current\": false}})\r\n\r\n        #update(if already present) entirely the presentation with the fresh data\r\n        removePresentationFromCollection meetingId, presentationId\r\n        addPresentationToCollection meetingId, message.payload.presentation\r\n\r\n        for slide in message.payload.presentation?.pages\r\n          addSlideToCollection meetingId, message.payload.presentation?.id, slide\r\n          if slide.current\r\n            displayThisSlide meetingId, slide.id, slide\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"get_presentation_info_reply\" and message.payload.requester_id is \"nodeJSapp\"\r\n        for presentation in message.payload.presentations\r\n          addPresentationToCollection meetingId, presentation\r\n\r\n          for page in presentation.pages\r\n            #add the slide to the collection\r\n            addSlideToCollection meetingId, presentation.id, page\r\n\r\n            #request for shapes\r\n            whiteboardId = \"#{presentation.id}/#{page.num}\" # d2d9a672040fbde2a47a10bf6c37b6a4b5ae187f-1404411622872/1\r\n            #Meteor.log.info \"the whiteboard_id here is:\" + whiteboardId\r\n\r\n            message =\r\n              \"payload\":\r\n                \"meeting_id\": meetingId\r\n                \"requester_id\": \"nodeJSapp\"\r\n                \"whiteboard_id\": whiteboardId\r\n              \"header\":\r\n                \"timestamp\": new Date().getTime()\r\n                \"name\": \"get_whiteboard_shapes_request\"\r\n                \"version\": \"0.0.1\"\r\n\r\n            if whiteboardId? and meetingId?\r\n              publish Meteor.config.redis.channels.toBBBApps.whiteboard, message #TODO\r\n            else\r\n              Meteor.log.info \"did not have enough information to send a user_leaving_request\" #TODO\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"presentation_page_changed_message\"\r\n        newSlide = message.payload.page\r\n        displayThisSlide meetingId, newSlide?.id, newSlide\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"presentation_removed_message\"\r\n        presentationId = message.payload.presentation_id\r\n        meetingId = message.payload.meeting_id\r\n        removePresentationFromCollection meetingId, presentationId\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"get_whiteboard_shapes_reply\" and message.payload.requester_id is \"nodeJSapp\"\r\n        # Create a whiteboard clean status or find one for the current meeting\r\n        if not Meteor.WhiteboardCleanStatus.findOne({meetingId: meetingId})?\r\n          Meteor.WhiteboardCleanStatus.insert({meetingId: meetingId, in_progress: false})\r\n\r\n        for shape in message.payload.shapes\r\n          whiteboardId = shape.wb_id\r\n          addShapeToCollection meetingId, whiteboardId, shape\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"send_whiteboard_shape_message\"\r\n        #Meteor stringifies an array of JSONs (...shape.result) in this message\r\n        #parsing the String and reassigning the value\r\n        if message.payload.shape.shape_type is \"poll_result\" and typeof message.payload.shape.shape.result is 'string'\r\n          message.payload.shape.shape.result = JSON.parse message.payload.shape.shape.result\r\n\r\n        shape = message.payload.shape\r\n        whiteboardId = shape?.wb_id\r\n        addShapeToCollection meetingId, whiteboardId, shape\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"presentation_cursor_updated_message\"\r\n        x = message.payload.x_percent\r\n        y = message.payload.y_percent\r\n        Meteor.Presentations.update({\"presentation.current\": true, meetingId: meetingId},\r\n          {$set: {\"pointer.x\": x, \"pointer.y\": y}})\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"whiteboard_cleared_message\"\r\n        whiteboardId = message.payload.whiteboard_id\r\n        Meteor.WhiteboardCleanStatus.update({meetingId: meetingId}, {$set: {'in_progress': true}})\r\n        removeAllShapesFromSlide meetingId, whiteboardId\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"undo_whiteboard_request\"\r\n        whiteboardId = message.payload.whiteboard_id\r\n        shapeId = message.payload.shape_id\r\n        removeShapeFromSlide meetingId, whiteboardId, shapeId\r\n        callback()\r\n\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"presentation_page_resized_message\"\r\n        slideId = message.payload.page?.id\r\n        heightRatio = message.payload.page?.height_ratio\r\n        widthRatio = message.payload.page?.width_ratio\r\n        xOffset = message.payload.page?.x_offset\r\n        yOffset = message.payload.page?.y_offset\r\n        presentationId = slideId.split(\"/\")[0]\r\n        Meteor.Slides.update({presentationId: presentationId, \"slide.current\": true},\r\n          {$set:{\"slide.height_ratio\": heightRatio,\"slide.width_ratio\": widthRatio,\"slide.x_offset\":xOffset,\"slide.y_offset\":yOffset}}\r\n        )\r\n        callback()\r\n\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"recording_status_changed_message\"\r\n        intendedForRecording = message.payload.recorded\r\n        currentlyBeingRecorded = message.payload.recording\r\n        Meteor.Meetings.update({meetingId: meetingId, intendedForRecording: intendedForRecording},\r\n          {$set: {currentlyBeingRecorded: currentlyBeingRecorded}}\r\n        )\r\n        callback()\r\n\r\n      # --------------------------------------------------\r\n      # lock settings ------------------------------------\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"eject_voice_user_message\"\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"new_permission_settings\"\r\n        oldSettings = Meteor.Meetings.findOne({meetingId:meetingId})?.roomLockSettings\r\n        newSettings = message.payload?.permissions\r\n\r\n        # if the disableMic setting was turned on\r\n        if !oldSettings?.disableMic and newSettings.disableMic\r\n          handleLockingMic(meetingId, newSettings)\r\n\r\n        # substitute with the new lock settings\r\n        Meteor.Meetings.update({meetingId: meetingId}, {$set: {\r\n          'roomLockSettings.disablePrivateChat': newSettings.disablePrivateChat\r\n          'roomLockSettings.disableCam': newSettings.disableCam\r\n          'roomLockSettings.disableMic': newSettings.disableMic\r\n          'roomLockSettings.lockOnJoin': newSettings.lockOnJoin\r\n          'roomLockSettings.lockedLayout': newSettings.lockedLayout\r\n          'roomLockSettings.disablePublicChat': newSettings.disablePublicChat\r\n          'roomLockSettings.lockOnJoinConfigurable': newSettings.lockOnJoinConfigurable #TODO\r\n        }})\r\n        callback()\r\n\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"poll_started_message\"\r\n        if message.payload.meeting_id? and message.payload.requester_id? and message.payload.poll?\r\n          if Meteor.Meetings.findOne({meetingId: message.payload.meeting_id})?\r\n            #initializing the list of current users\r\n            users = Meteor.Users.find({meetingId: message.payload.meeting_id},\r\n              {fields:{\"user.userid\": 1, _id: 0}} ).fetch()\r\n            addPollToCollection message.payload.poll, message.payload.requester_id,\r\n              users, message.payload.meeting_id\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"poll_stopped_message\"\r\n        meetingId = message.payload.meeting_id\r\n        poll_id = message.payload.poll_id\r\n        clearPollCollection meetingId, poll_id\r\n        callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"user_voted_poll_message\"\r\n        if message.payload?.poll? and message.payload.meeting_id? and message.payload.presenter_id?\r\n          pollObj = message.payload.poll\r\n          meetingId = message.payload.meeting_id\r\n          requesterId = message.payload.presenter_id\r\n          updatePollCollection pollObj, meetingId, requesterId\r\n          callback()\r\n\r\n      # for now not handling this serially #TODO\r\n      else if eventName is \"poll_show_result_message\"\r\n        if message.payload.poll.id? and message.payload.meeting_id?\r\n          poll_id = message.payload.poll.id\r\n          meetingId = message.payload.meeting_id\r\n          clearPollCollection meetingId, poll_id\r\n        callback()\r\n\r\n\r\n      else # keep moving in the queue\r\n        unless eventName in notLoggedEventTypes\r\n          Meteor.log.info \"WARNING!!!\r\n          THE JSON MESSAGE WAS NOT OF TYPE SUPPORTED BY THIS APPLICATION\\n\r\n          #{eventName}   {JSON.stringify message}\"\r\n        callback()\r\n    else\r\n      callback()\r\n"]}}