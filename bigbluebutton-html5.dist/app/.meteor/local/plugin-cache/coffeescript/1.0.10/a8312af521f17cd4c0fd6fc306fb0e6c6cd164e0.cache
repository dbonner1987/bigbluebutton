{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nthis.WhiteboardRectModel = (function(superClass) {\n  extend(WhiteboardRectModel, superClass);\n\n  function WhiteboardRectModel(paper) {\n    this.paper = paper;\n    this.make = bind(this.make, this);\n    WhiteboardRectModel.__super__.constructor.call(this, this.paper);\n    this.definition = [0, 0, 0, 0, \"#000\", \"0px\"];\n    this.paper;\n  }\n\n  WhiteboardRectModel.prototype.make = function(startingData) {\n    var color, thickness, x, y;\n    x = startingData.points[0];\n    y = startingData.points[1];\n    color = startingData.color;\n    thickness = startingData.thickness;\n    this.obj = this.paper.rect(x * this.gw + this.xOffset, y * this.gh + this.yOffset, 0, 0, 1);\n    this.obj.attr(\"stroke\", formatColor(color));\n    this.obj.attr(\"stroke-width\", zoomStroke(formatThickness(thickness)));\n    this.definition = {\n      shape: \"rect\",\n      data: [x, y, 0, 0, this.obj.attrs[\"stroke\"], this.obj.attrs[\"stroke-width\"]]\n    };\n    return this.obj;\n  };\n\n  WhiteboardRectModel.prototype.update = function(startingData) {\n    var height, ref, ref1, reversed, square, width, x, x1, x2, y, y1, y2;\n    x1 = startingData.points[0];\n    y1 = startingData.points[1];\n    x2 = startingData.points[2];\n    y2 = startingData.points[3];\n    square = startingData.square;\n    if (this.obj != null) {\n      if (x2 < x1) {\n        ref = [x2, x1], x1 = ref[0], x2 = ref[1];\n      }\n      if (y2 < y1) {\n        ref1 = [y2, y1], y1 = ref1[0], y2 = ref1[1];\n        reversed = true;\n      }\n      if (square) {\n        if (reversed) {\n          y1 = y2 - (x2 - x1) * this.gw / this.gh;\n        } else {\n          y2 = y1 + (x2 - x1) * this.gw / this.gh;\n        }\n      }\n      x = x1 * this.gw + this.xOffset;\n      y = y1 * this.gh + this.yOffset;\n      width = (x2 * this.gw + this.xOffset) - x;\n      height = (y2 * this.gh + this.yOffset) - y;\n      this.obj.attr({\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n\n      /*else\n        @obj.attr\n          x: x\n          y: y\n          width: width\n          height: width\n       */\n      this.definition.data[0] = x1;\n      this.definition.data[1] = y1;\n      this.definition.data[2] = x2;\n      return this.definition.data[3] = y2;\n    }\n  };\n\n  WhiteboardRectModel.prototype.draw = function(x1, y1, x2, y2, colour, thickness) {\n    var r, ref, ref1, x, y;\n    if (x2 < x1) {\n      ref = [x2, x1], x1 = ref[0], x2 = ref[1];\n    }\n    if (y2 < y1) {\n      ref1 = [y2, y1], y1 = ref1[0], y2 = ref1[1];\n    }\n    x = x1 * this.gw;\n    y = y1 * this.gh;\n    r = this.paper.rect(x + this.xOffset, y + this.yOffset, (x2 * this.gw) - x, (y2 * this.gh) - y, 1);\n    r.attr(Meteor.call(\"strokeAndThickness\", colour, thickness));\n    return r;\n  };\n\n  WhiteboardRectModel.prototype.dragOnStart = function(x, y) {};\n\n  WhiteboardRectModel.prototype.dragOnMove = function(dx, dy, x, y, e) {};\n\n  WhiteboardRectModel.prototype.dragOnEnd = function(e) {};\n\n  return WhiteboardRectModel;\n\n})(WhiteboardToolModel);\n","sourceMap":{"version":3,"file":"/client/whiteboard_models/whiteboard_rect.coffee.js","sourceRoot":"","sources":["/client/whiteboard_models/whiteboard_rect.coffee"],"names":[],"mappings":"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","sourcesContent":["# A rectangle in the whiteboard\nclass @WhiteboardRectModel extends WhiteboardToolModel\n  constructor: (@paper) ->\n    super @paper\n\n    # the defintion of this shape, kept so we can redraw the shape whenever needed\n    # format: x1, y1, x2, y2, stroke color, thickness\n    @definition = [0, 0, 0, 0, \"#000\", \"0px\"]\n    @paper\n\n  # Creates a rectangle in the paper\n  # @param  {number} x         the x value of the top left corner\n  # @param  {number} y         the y value of the top left corner\n  # @param  {string} colour    the colour of the object\n  # @param  {number} thickness the thickness of the object's line(s)\n  make: (startingData) =>\n    x = startingData.points[0]\n    y = startingData.points[1]\n    color = startingData.color\n    thickness = startingData.thickness\n\n    @obj = @paper.rect(x * @gw + @xOffset, y * @gh + @yOffset, 0, 0, 1)\n    @obj.attr \"stroke\", formatColor(color)\n    @obj.attr \"stroke-width\", zoomStroke(formatThickness(thickness))\n    @definition =\n      shape: \"rect\"\n      data: [x, y, 0, 0, @obj.attrs[\"stroke\"], @obj.attrs[\"stroke-width\"]]\n    @obj\n\n  # Update the rectangle dimensions\n  # @param  {number} x1 the x value of the top left corner\n  # @param  {number} y1 the y value of the top left corner\n  # @param  {number} x2 the x value of the bottom right corner\n  # @param  {number} y2 the y value of the bottom right corner\n  # @param  {boolean} square (draw a square or not)\n  update: (startingData) ->\n\n    x1 = startingData.points[0]\n    y1 = startingData.points[1]\n    x2 = startingData.points[2]\n    y2 = startingData.points[3]\n\n    square = startingData.square\n    if @obj?\n      [x1, x2] = [x2, x1] if x2 < x1\n\n      if y2 < y1\n          [y1, y2] = [y2, y1]\n          reversed = true\n\n      if square\n          if reversed #if reveresed, the y1 coordinate gets updated, not the y2 coordinate\n              y1 = y2 - (x2 - x1) * @gw / @gh\n          else\n              y2 = y1 + (x2 - x1) * @gw / @gh\n\n      x = x1 * @gw + @xOffset\n      y = y1 * @gh + @yOffset\n      width = (x2 * @gw + @xOffset) - x\n      height = (y2 * @gh + @yOffset) - y\n      #if !square\n      @obj.attr\n        x: x\n        y: y\n        width: width\n        height: height\n      ###else\n        @obj.attr\n          x: x\n          y: y\n          width: width\n          height: width###\n\n      # we need to update all these values, specially for when shapes are drawn backwards\n      @definition.data[0] = x1\n      @definition.data[1] = y1\n      @definition.data[2] = x2\n      @definition.data[3] = y2\n\n  # Draw a rectangle on the paper\n  # @param  {number} x1        the x value of the top left corner\n  # @param  {number} y1        the y value of the top left corner\n  # @param  {number} x2        the x value of the bottom right corner\n  # @param  {number} y2        the y value of the bottom right corner\n  # @param  {string} colour    the colour of the object\n  # @param  {number} thickness the thickness of the object's line(s)\n  draw: (x1, y1, x2, y2, colour, thickness) ->\n    [x1, x2] = [x2, x1] if x2 < x1\n    [y1, y2] = [y2, y1] if y2 < y1\n\n    x = x1 * @gw\n    y = y1 * @gh\n    r = @paper.rect(x + @xOffset, y + @yOffset, (x2 * @gw) - x, (y2 * @gh) - y, 1)\n    r.attr Meteor.call(\"strokeAndThickness\", colour, thickness)\n    r\n\n  # Creating a rectangle has started\n  # @param  {number} x the x value of cursor at the time in relation to the left side of the browser\n  # @param  {number} y the y value of cursor at the time in relation to the top of the browser\n  # TODO: moved here but not finished\n  dragOnStart: (x, y) ->\n    # sx = (@paperWidth - @gw) / 2\n    # sy = (@paperHeight - @gh) / 2\n    # # find the x and y values in relation to the whiteboard\n    # @cx2 = (x - @containerOffsetLeft - sx + @xOffset) / @paperWidth\n    # @cy2 = (y - @containerOffsetTop - sy + @yOffset) / @paperHeight\n    # globals.connection.emitMakeShape \"rect\",\n    #   [ @cx2, @cy2, @currentColour, @currentThickness ]\n\n  # Adjusting rectangle continues\n  # @param  {number} dx the difference in the x value at the start as opposed to the x value now\n  # @param  {number} dy the difference in the y value at the start as opposed to the y value now\n  # @param  {number} x the x value of cursor at the time in relation to the left side of the browser\n  # @param  {number} y the y value of cursor at the time in relation to the top of the browser\n  # @param  {Event} e  the mouse event\n  # TODO: moved here but not finished\n  dragOnMove: (dx, dy, x, y, e) ->\n    # # if shift is pressed, make it a square\n    # dy = dx if @shiftPressed\n    # dx = dx / @paperWidth\n    # dy = dy / @paperHeight\n    # # adjust for negative values as well\n    # if dx >= 0\n    #   x1 = @cx2\n    # else\n    #   x1 = @cx2 + dx\n    #   dx = -dx\n    # if dy >= 0\n    #   y1 = @cy2\n    # else\n    #   y1 = @cy2 + dy\n    #   dy = -dy\n    # globals.connection.emitUpdateShape \"rect\", [ x1, y1, dx, dy ]\n\n  # When rectangle finished being drawn\n  # @param  {Event} e the mouse event\n  # TODO: moved here but not finished\n  dragOnEnd: (e) ->\n    # if @obj?\n    #   attrs = @obj.attrs\n    #   if attrs?\n    #     globals.connection.emitPublishShape \"rect\",\n    #       [ attrs.x / @gw, attrs.y / @gh, attrs.width / @gw, attrs.height / @gh,\n    #         @currentColour, @currentThickness ]\n    # @obj = null\n"]}}