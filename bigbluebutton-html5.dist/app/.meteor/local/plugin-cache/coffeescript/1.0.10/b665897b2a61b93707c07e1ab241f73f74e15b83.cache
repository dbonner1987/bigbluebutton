{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar MAX_PATHS_IN_SEQUENCE,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nMAX_PATHS_IN_SEQUENCE = 30;\n\nthis.WhiteboardLineModel = (function(superClass) {\n  extend(WhiteboardLineModel, superClass);\n\n  function WhiteboardLineModel(paper) {\n    this.paper = paper;\n    WhiteboardLineModel.__super__.constructor.call(this, this.paper);\n    this.definition = [\"\", \"#000\", \"0px\"];\n  }\n\n  WhiteboardLineModel.prototype.make = function(info) {\n    var color, path, pathPercent, thickness, x, x1, y, y1;\n    if ((info != null ? info.points : void 0) != null) {\n      x = info.points[0];\n      y = info.points[1];\n      color = info.color;\n      thickness = info.thickness;\n      x1 = x * this.gw + this.xOffset;\n      y1 = y * this.gh + this.yOffset;\n      path = \"M\" + x1 + \" \" + y1 + \" L\" + x1 + \" \" + y1;\n      pathPercent = \"M\" + x + \" \" + y + \" L\" + x + \" \" + y;\n      this.obj = this.paper.path(path);\n      this.obj.attr(\"stroke\", formatColor(color));\n      this.obj.attr(\"stroke-width\", zoomStroke(formatThickness(thickness)));\n      this.obj.attr({\n        \"stroke-linejoin\": \"round\"\n      });\n      this.obj.attr(\"stroke-linecap\", \"round\");\n      this.definition = [pathPercent, this.obj.attrs[\"stroke\"], this.obj.attrs[\"stroke-width\"]];\n    }\n    return this.obj;\n  };\n\n  WhiteboardLineModel.prototype.update = function(info) {\n    var path, x1, x2, y1, y2;\n    if ((info != null ? info.points : void 0) != null) {\n      x1 = info.points[0];\n      y1 = info.points[1];\n      x2 = info.points[2];\n      y2 = info.points[3];\n      if (this.obj != null) {\n        path = this._buildPath(info.points);\n        this.definition[0] = path;\n        path = this._scaleLinePath(path, this.gw, this.gh, this.xOffset, this.yOffset);\n        return this.obj.attr({\n          path: path\n        });\n      }\n    }\n  };\n\n  WhiteboardLineModel.prototype.draw = function(x1, y1, x2, y2, colour, thickness) {};\n\n  WhiteboardLineModel.prototype.dragOnStart = function(x, y) {};\n\n  WhiteboardLineModel.prototype.dragOnMove = function(dx, dy, x, y) {};\n\n  WhiteboardLineModel.prototype.dragOnEnd = function(e) {};\n\n  WhiteboardLineModel.prototype._buildPath = function(points) {\n    var i, path;\n    path = \"\";\n    if (points && points.length >= 2) {\n      path += \"M \" + points[0] + \" \" + points[1];\n      i = 2;\n      while (i < points.length) {\n        path += \"L\" + points[i] + \" \" + points[i + 1];\n        i += 2;\n      }\n      path += \"Z\";\n      return path;\n    }\n  };\n\n  WhiteboardLineModel.prototype._scaleLinePath = function(string, w, h, xOffset, yOffset) {\n    var j, len, path, points;\n    if (xOffset == null) {\n      xOffset = 0;\n    }\n    if (yOffset == null) {\n      yOffset = 0;\n    }\n    path = null;\n    points = string.match(/(\\d+[.]?\\d*)/g);\n    len = points.length;\n    j = 0;\n    while (j < len) {\n      if (j !== 0) {\n        path += \"L\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset);\n      } else {\n        path = \"M\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset);\n      }\n      j += 2;\n    }\n    return path;\n  };\n\n  return WhiteboardLineModel;\n\n})(WhiteboardToolModel);\n","sourceMap":{"version":3,"file":"/client/whiteboard_models/whiteboard_line.coffee.js","sourceRoot":"","sources":["/client/whiteboard_models/whiteboard_line.coffee"],"names":[],"mappings":"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","sourcesContent":["MAX_PATHS_IN_SEQUENCE = 30\n\n# A line in the whiteboard\n# Note: is used to draw lines from the pencil tool and from the line tool, this is why some\n# methods can receive different set of parameters.\n# TODO: Maybe this should be split in WhiteboardPathModel for the pencil and\n#       WhiteboardLineModel for the line tool\nclass @WhiteboardLineModel extends WhiteboardToolModel\n\n  constructor: (@paper) ->\n    super @paper\n\n    # the defintion of this shape, kept so we can redraw the shape whenever needed\n    # format: svg path, stroke color, thickness\n    @definition = [\"\", \"#000\", \"0px\"]\n\n  # Creates a line in the paper\n  # @param  {number} x         the x value of the line start point as a percentage of the original width\n  # @param  {number} y         the y value of the line start point as a percentage of the original height\n  # @param  {string} colour    the colour of the shape to be drawn\n  # @param  {number} thickness the thickness of the line to be drawn\n  make: (info) ->\n\n    if info?.points?\n      x = info.points[0]\n      y = info.points[1]\n      color = info.color\n      thickness = info.thickness\n\n      x1 = x * @gw + @xOffset\n      y1 = y * @gh + @yOffset\n      path = \"M\" + x1 + \" \" + y1 + \" L\" + x1 + \" \" + y1\n      pathPercent = \"M\" + x + \" \" + y + \" L\" + x + \" \" + y\n      @obj = @paper.path(path)\n      @obj.attr \"stroke\", formatColor(color)\n      @obj.attr \"stroke-width\", zoomStroke(formatThickness(thickness))\n      @obj.attr({\"stroke-linejoin\": \"round\"})\n      @obj.attr \"stroke-linecap\", \"round\"\n\n      @definition = [pathPercent, @obj.attrs[\"stroke\"], @obj.attrs[\"stroke-width\"]]\n\n    @obj\n\n  # Update the line dimensions\n  # @param  {number}  x1         1) the x of the first point\n  #                              2) the next x point to be added to the line\n  # @param  {number}  y1         1) the y of the first point\n  #                              2) the next y point to be added to the line\n  # @param  {number,boolean} x2  1) the x of the second point\n  #                              2) true if the line should be added to the current line,\n  #                                 false if it should replace the last point\n  # @param  {number}         y2  1) the y of the second point\n  #                              2) undefined\n  update: (info) ->\n\n    if info?.points?\n      x1 = info.points[0]\n      y1 = info.points[1]\n      x2 = info.points[2]\n      y2 = info.points[3]\n\n      if @obj?\n        path = @_buildPath(info.points)\n\n        @definition[0] = path\n\n        path = @_scaleLinePath(path, @gw, @gh, @xOffset, @yOffset)\n        @obj.attr path: path\n\n  # Draw a line on the paper\n  # @param  {number,string} x1 1) the x value of the first point\n  #                            2) the string path\n  # @param  {number,string} y1 1) the y value of the first point\n  #                            2) the colour\n  # @param  {number} x2        1) the x value of the second point\n  #                            2) the thickness\n  # @param  {number} y2        1) the y value of the second point\n  #                            2) undefined\n  # @param  {string} colour    1) the colour of the shape to be drawn\n  #                            2) undefined\n  # @param  {number} thickness 1) the thickness of the line to be drawn\n  #                            2) undefined\n  draw: (x1, y1, x2, y2, colour, thickness) ->\n\n    # if the drawing is from the pencil tool, it comes as a path first\n    # if _.isString(x1)\n    #   colour = y1\n    #   thickness = x2\n    #   path = x1\n\n    # # if the drawing is from the line tool, it comes with two points\n    # else\n    #   path = @_buildPath(points)\n\n    # line = @paper.path(@_scaleLinePath(path, @gw, @gh, @xOffset, @yOffset))\n    # line.attr Utils.strokeAndThickness(colour, thickness)\n    # line.attr({\"stroke-linejoin\": \"round\"})\n    # line\n\n  # When dragging for drawing lines starts\n  # @param  {number} x the x value of the cursor\n  # @param  {number} y the y value of the cursor\n  # TODO: moved here but not finished\n  dragOnStart: (x, y) ->\n    # # find the x and y values in relation to the whiteboard\n    # sx = (@paperWidth - @gw) / 2\n    # sy = (@paperHeight - @gh) / 2\n    # @lineX = x - @containerOffsetLeft - sx + @xOffset\n    # @lineY = y - @containerOffsetTop - sy + @yOffset\n    # values = [ @lineX / @paperWidth, @lineY / @paperHeight, @currentColour, @currentThickness ]\n    # globals.connection.emitMakeShape \"line\", values\n\n  # As line drawing drag continues\n  # @param  {number} dx the difference between the x value from _lineDragStart and now\n  # @param  {number} dy the difference between the y value from _lineDragStart and now\n  # @param  {number} x  the x value of the cursor\n  # @param  {number} y  the y value of the cursor\n  # TODO: moved here but not finished\n  dragOnMove: (dx, dy, x, y) ->\n    # sx = (@paperWidth - @gw) / 2\n    # sy = (@paperHeight - @gh) / 2\n    # [cx, cy] = @_currentSlideOffsets()\n    # # find the x and y values in relation to the whiteboard\n    # @cx2 = x - @containerOffsetLeft - sx + @xOffset\n    # @cy2 = y - @containerOffsetTop - sy + @yOffset\n    # if @shiftPressed\n    #   globals.connection.emitUpdateShape \"line\", [ @cx2 / @paperWidth, @cy2 / @paperHeight, false ]\n    # else\n    #   @currentPathCount++\n    #   if @currentPathCount < MAX_PATHS_IN_SEQUENCE\n    #     globals.connection.emitUpdateShape \"line\", [ @cx2 / @paperHeight, @cy2 / @paperHeight, true ]\n    #   else if @obj?\n    #     @currentPathCount = 0\n    #     # save the last path of the line\n    #     @obj.attrs.path.pop()\n    #     path = @obj.attrs.path.join(\" \")\n    #     @obj.attr path: (path + \"L\" + @lineX + \" \" + @lineY)\n\n    #     # scale the path appropriately before sending\n    #     pathStr = @obj.attrs.path.join(\",\")\n    #     globals.connection.emitPublishShape \"path\",\n    #       [ @_scaleLinePath(pathStr, 1 / @gw, 1 / @gh),\n    #         @currentColour, @currentThickness ]\n    #     globals.connection.emitMakeShape \"line\",\n    #       [ @lineX / @paperWidth, @lineY / @paperHeight, @currentColour, @currentThickness ]\n    #   @lineX = @cx2\n    #   @lineY = @cy2\n\n  # Drawing line has ended\n  # @param  {Event} e the mouse event\n  # TODO: moved here but not finished\n  dragOnEnd: (e) ->\n    # if @obj?\n    #   path = @obj.attrs.path\n    #   @obj = null # any late updates will be blocked by this\n    #   # scale the path appropriately before sending\n    #   globals.connection.emitPublishShape \"path\",\n    #     [ @_scaleLinePath(path.join(\",\"), 1 / @gw, 1 / @gh),\n    #       @currentColour, @currentThickness ]\n\n  _buildPath: (points) ->\n    path = \"\"\n\n    if points and points.length >= 2\n      path += \"M #{points[0]} #{points[1]}\"\n      i = 2\n\n      while i < points.length\n        path += \"L#{points[i]} #{points[i + 1]}\"\n        i += 2\n\n      path += \"Z\"\n      path\n\n  # Scales a path string to fit within a width and height of the new paper size\n  # @param  {number} w width of the shape as a percentage of the original width\n  # @param  {number} h height of the shape as a percentage of the original height\n  # @return {string}   the path string after being manipulated to new paper size\n  _scaleLinePath: (string, w, h, xOffset=0, yOffset=0) ->\n    path = null\n    points = string.match(/(\\d+[.]?\\d*)/g)\n    len = points.length\n    j = 0\n\n    # go through each point and multiply it by the new height and width\n    while j < len\n      if j isnt 0\n        path += \"L\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset)\n      else\n        path = \"M\" + (points[j] * w + xOffset) + \",\" + (points[j + 1] * h + yOffset)\n      j += 2\n    path\n"]}}