{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nthis.WhiteboardTextModel = (function(superClass) {\n  var checkDashPosition, checkWidth;\n\n  extend(WhiteboardTextModel, superClass);\n\n  function WhiteboardTextModel(paper) {\n    this.paper = paper;\n    WhiteboardTextModel.__super__.constructor.call(this, this.paper);\n    this.definition = [0, 0, 0, 0, \"#000\", 0, 0, \"\"];\n  }\n\n  WhiteboardTextModel.prototype.make = function(startingData) {\n    var calcFontSize, colour, fontSize, height, text, width, x, y;\n    x = startingData.x;\n    y = startingData.y;\n    width = startingData.textBoxWidth;\n    height = startingData.textBoxHeight;\n    colour = formatColor(startingData.fontColor);\n    fontSize = startingData.fontSize;\n    calcFontSize = startingData.calcedFontSize;\n    text = startingData.text;\n    this.definition = {\n      shape: \"text\",\n      data: [x, y, width, height, colour, fontSize, calcFontSize, text]\n    };\n    x = (x * this.gw) + this.xOffset;\n    y = (y * this.gh) + this.yOffset + calcFontSize;\n    width = width / 100 * this.gw;\n    this.obj = this.paper.text(x / 100, y / 100, \"\");\n    this.obj.attr({\n      \"fill\": colour,\n      \"font-family\": \"Arial\",\n      \"font-size\": calcFontSize\n    });\n    this.obj.node.style[\"text-anchor\"] = \"start\";\n    this.obj.node.style[\"textAnchor\"] = \"start\";\n    return this.obj;\n  };\n\n  WhiteboardTextModel.prototype.update = function(startingData) {\n    var calcFontSize, cell, colour, computedTextLength, cumulY, curNumChars, dashArray, dashFound, dy, fontSize, height, i, indexPos, line, maxWidth, myText, myTextNode, result, svgNS, tempText, tspanEl, word, words, x, y;\n    x = startingData.x;\n    y = startingData.y;\n    maxWidth = startingData.textBoxWidth;\n    height = startingData.textBoxHeight;\n    colour = formatColor(startingData.fontColor);\n    fontSize = startingData.fontSize;\n    calcFontSize = startingData.calcedFontSize;\n    myText = startingData.text;\n    if (this.obj != null) {\n      this.definition.data = [x, y, maxWidth, height, colour, fontSize, calcFontSize, myText];\n      calcFontSize = calcFontSize / 100 * this.gh;\n      x = (x * this.gw) / 100 + this.xOffset;\n      maxWidth = maxWidth / 100 * this.gw;\n      this.obj.attr({\n        \"fill\": colour,\n        \"font-family\": \"Arial\",\n        \"font-size\": calcFontSize\n      });\n      cell = this.obj.node;\n      while ((cell != null) && cell.hasChildNodes()) {\n        cell.removeChild(cell.firstChild);\n      }\n      dashArray = new Array();\n      dashFound = true;\n      indexPos = 0;\n      cumulY = 0;\n      svgNS = \"http://www.w3.org/2000/svg\";\n      while (dashFound === true) {\n        result = myText.indexOf(\"-\", indexPos);\n        if (result === -1) {\n          dashFound = false;\n        } else {\n          dashArray.push(result);\n          indexPos = result + 1;\n        }\n      }\n      words = myText.split(/[\\s-]/);\n      line = \"\";\n      dy = 0;\n      curNumChars = 0;\n      computedTextLength = 0;\n      myTextNode = void 0;\n      tspanEl = void 0;\n      i = 0;\n      words = checkWidth(words, maxWidth, x, dy, cell);\n      while (i < words.length) {\n        word = words[i];\n        curNumChars += word.length + 1;\n        if (computedTextLength > maxWidth || i === 0) {\n          if (computedTextLength > maxWidth) {\n            tempText = tspanEl.firstChild.nodeValue;\n            tempText = tempText.slice(0, tempText.length - words[i - 1].length - 2);\n            tspanEl.firstChild.nodeValue = tempText;\n          }\n          if (i === 0) {\n            dy = calcFontSize;\n            cumulY += dy;\n          }\n          tspanEl = document.createElementNS(svgNS, \"tspan\");\n          tspanEl.setAttributeNS(null, \"x\", x);\n          tspanEl.setAttributeNS(null, \"dy\", dy);\n          myTextNode = document.createTextNode(line);\n          tspanEl.appendChild(myTextNode);\n          cell.appendChild(tspanEl);\n          if (checkDashPosition(dashArray, curNumChars - 1)) {\n            line = word + \"-\";\n          } else {\n            line = word + \" \";\n          }\n          if (i !== 0) {\n            line = words[i - 1] + \" \" + line;\n          }\n          dy = calcFontSize;\n          cumulY += dy;\n        } else {\n          if (checkDashPosition(dashArray, curNumChars - 1)) {\n            line += word + \"-\";\n          } else {\n            line += word + \" \";\n          }\n        }\n        tspanEl.firstChild.nodeValue = line;\n        computedTextLength = tspanEl.getComputedTextLength() + 10;\n        if (i === words.length - 1) {\n          if (computedTextLength > maxWidth) {\n            tempText = tspanEl.firstChild.nodeValue;\n            tspanEl.firstChild.nodeValue = tempText.slice(0, tempText.length - words[i].length - 1);\n            tspanEl = document.createElementNS(svgNS, \"tspan\");\n            tspanEl.setAttributeNS(null, \"x\", x);\n            tspanEl.setAttributeNS(null, \"dy\", dy);\n            myTextNode = document.createTextNode(words[i]);\n            tspanEl.appendChild(myTextNode);\n            cell.appendChild(tspanEl);\n          }\n        }\n        i++;\n      }\n      return cumulY;\n    }\n  };\n\n  checkDashPosition = function(dashArray, pos) {\n    var i, result;\n    result = false;\n    i = 0;\n    while (i < dashArray.length) {\n      if (dashArray[i] === pos) {\n        result = true;\n      }\n      i++;\n    }\n    return result;\n  };\n\n  checkWidth = function(words, maxWidth, x, dy, cell) {\n    var count, num, partWord, start, str, svgNSi, temp, temp3, tempArray, tempSpanEl, tempTextNode, tempWord;\n    count = 0;\n    temp = words;\n    temp3 = [];\n    str = \"\";\n    svgNSi = \"http://www.w3.org/2000/svg\";\n    tempSpanEl = document.createElementNS(svgNSi, \"tspan\");\n    tempSpanEl.setAttributeNS(null, \"x\", x);\n    tempSpanEl.setAttributeNS(null, \"dy\", dy);\n    tempTextNode = document.createTextNode(str);\n    tempSpanEl.appendChild(tempTextNode);\n    num = 0;\n    while (num < temp.length) {\n      tempSpanEl.firstChild.nodeValue = temp[num];\n      cell.appendChild(tempSpanEl);\n      if (tempSpanEl.getComputedTextLength() + 10 > maxWidth) {\n        tempWord = temp[num];\n        cell.removeChild(cell.firstChild);\n        count = 1;\n        start = 0;\n        partWord = \"\" + tempWord[0];\n        tempArray = [];\n        while (count < tempWord.length) {\n          partWord += tempWord[count];\n          tempSpanEl.firstChild.nodeValue = partWord;\n          cell.appendChild(tempSpanEl);\n          if (tempSpanEl.getComputedTextLength() + 10 > maxWidth) {\n            temp3.push(partWord.substring(0, partWord.length - 1));\n            partWord = \"\";\n            partWord += tempWord[count];\n          }\n          if (count === tempWord.length - 1) {\n            temp3.push(partWord);\n          }\n          while ((cell != null) && cell.hasChildNodes()) {\n            cell.removeChild(cell.firstChild);\n          }\n          count++;\n        }\n      } else {\n        temp3.push(temp[num]);\n      }\n      while ((cell != null) && cell.hasChildNodes()) {\n        cell.removeChild(cell.firstChild);\n      }\n      num++;\n    }\n    while ((cell != null) && cell.hasChildNodes()) {\n      cell.removeChild(cell.firstChild);\n    }\n    return temp3;\n  };\n\n  return WhiteboardTextModel;\n\n})(WhiteboardToolModel);\n","sourceMap":{"version":3,"file":"/client/whiteboard_models/whiteboard_text.coffee.js","sourceRoot":"","sources":["/client/whiteboard_models/whiteboard_text.coffee"],"names":[],"mappings":"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","sourcesContent":["# A text in the whiteboard\nclass @WhiteboardTextModel extends WhiteboardToolModel\n\n  constructor: (@paper) ->\n    super @paper\n    # the defintion of this shape, kept so we can redraw the shape whenever needed\n    # format: x, y, width, height, colour, fontSize, calcFontSize, text\n    @definition = [0, 0, 0, 0, \"#000\", 0, 0, \"\"]\n\n  # Make a text on the whiteboard\n  make: (startingData) ->\n    #console.log \"making text:\" + JSON.stringify startingData\n\n    x = startingData.x\n    y = startingData.y\n    width = startingData.textBoxWidth\n    height = startingData.textBoxHeight\n    colour = formatColor(startingData.fontColor)\n    fontSize = startingData.fontSize\n    calcFontSize = startingData.calcedFontSize\n    text = startingData.text\n\n    @definition =\n      shape: \"text\"\n      data: [x, y, width, height, colour, fontSize, calcFontSize, text]\n\n    #calcFontSize = (calcFontSize/100 * @gh)\n    x = (x * @gw) + @xOffset\n    y = (y * @gh) + @yOffset + calcFontSize\n    width = width/100 * @gw\n\n    @obj = @paper.text(x/100, y/100, \"\")\n    @obj.attr\n      \"fill\": colour\n      \"font-family\": \"Arial\" # TODO: make dynamic\n      \"font-size\": calcFontSize\n    @obj.node.style[\"text-anchor\"] = \"start\" # force left align\n    @obj.node.style[\"textAnchor\"] = \"start\"  # for firefox, 'cause they like to be different\n    @obj\n\n  # Update text shape drawn\n  # @param  {object} the object containing the shape info\n  update: (startingData) ->\n    #console.log \"updating text\" + JSON.stringify startingData\n\n    x = startingData.x\n    y = startingData.y\n    maxWidth = startingData.textBoxWidth\n    height = startingData.textBoxHeight\n    colour = formatColor(startingData.fontColor)\n    fontSize = startingData.fontSize\n    calcFontSize = startingData.calcedFontSize\n    myText = startingData.text\n\n    if @obj?\n      @definition.data = [x, y, maxWidth, height, colour, fontSize, calcFontSize, myText]\n\n      calcFontSize = (calcFontSize/100 * @gh)\n      x = (x * @gw)/100 + @xOffset\n      maxWidth = maxWidth/100 * @gw\n\n      @obj.attr\n        \"fill\": colour\n        \"font-family\": \"Arial\" # TODO: make dynamic\n        \"font-size\": calcFontSize\n      cell = @obj.node\n      while cell? and cell.hasChildNodes()\n        cell.removeChild(cell.firstChild)\n\n      # used code from textFlow lib http://www.carto.net/papers/svg/textFlow/\n      # but had to merge it here because \"cell\" was bigger than what the stack could take\n\n      #extract and add line breaks for start\n      dashArray = new Array()\n      dashFound = true\n      indexPos = 0\n      cumulY = 0\n      svgNS = \"http://www.w3.org/2000/svg\"\n      while dashFound is true\n        result = myText.indexOf(\"-\", indexPos)\n        if result is -1\n          #could not find a dash\n          dashFound = false\n        else\n          dashArray.push result\n          indexPos = result + 1\n      #split the text at all spaces and dashes\n      words = myText.split(/[\\s-]/)\n      line = \"\"\n      dy = 0\n      curNumChars = 0\n      computedTextLength = 0\n      myTextNode = undefined\n      tspanEl = undefined\n      i = 0\n\n      #checking if any of the words exceed the width of a textBox\n      words = checkWidth(words, maxWidth, x, dy, cell)\n\n      while i < words.length\n        word = words[i]\n        curNumChars += word.length + 1\n        if computedTextLength > maxWidth or i is 0\n          if computedTextLength > maxWidth\n            tempText = tspanEl.firstChild.nodeValue\n            tempText = tempText.slice(0, (tempText.length - words[i - 1].length - 2)) #the -2 is because we also strip off white space\n            tspanEl.firstChild.nodeValue = tempText\n          #setting up coordinates for the first line of text\n          if i is 0\n            dy = calcFontSize\n            cumulY += dy\n          #alternatively one could use textLength and lengthAdjust, however, currently this is not too well supported in SVG UA's\n          tspanEl = document.createElementNS(svgNS, \"tspan\")\n          tspanEl.setAttributeNS null, \"x\", x\n          tspanEl.setAttributeNS null, \"dy\", dy\n          myTextNode = document.createTextNode(line)\n          tspanEl.appendChild myTextNode\n          cell.appendChild tspanEl\n          if checkDashPosition(dashArray, curNumChars - 1)\n            line = word + \"-\"\n          else\n            line = word + \" \"\n          line = words[i - 1] + \" \" + line  unless i is 0\n          dy = calcFontSize\n          cumulY += dy\n        else\n          if checkDashPosition(dashArray, curNumChars - 1)\n            line += word + \"-\"\n          else\n            line += word + \" \"\n        tspanEl.firstChild.nodeValue = line\n        computedTextLength = tspanEl.getComputedTextLength()+10\n        if i is words.length - 1\n          if computedTextLength > maxWidth\n            tempText = tspanEl.firstChild.nodeValue\n            tspanEl.firstChild.nodeValue = tempText.slice(0, (tempText.length - words[i].length - 1))\n            tspanEl = document.createElementNS(svgNS, \"tspan\")\n            tspanEl.setAttributeNS null, \"x\", x\n            tspanEl.setAttributeNS null, \"dy\", dy\n            myTextNode = document.createTextNode(words[i])\n            tspanEl.appendChild myTextNode\n            cell.appendChild tspanEl\n        i++\n      cumulY\n\n\n  #this function checks if there should be a dash at the given position, instead of a blank\n  checkDashPosition = (dashArray, pos) ->\n    result = false\n    i = 0\n    while i < dashArray.length\n      result = true  if dashArray[i] is pos\n      i++\n    result\n  #this function checks the width of the word and adds a \" \" if the width of the word exceeds the width of the textbox\n  #in order for the word to be split and shown properly\n  checkWidth = (words, maxWidth, x, dy, cell) ->\n    count = 0\n    temp = words\n    temp3 = []\n    str = \"\"\n\n    svgNSi = \"http://www.w3.org/2000/svg\"\n    tempSpanEl = document.createElementNS(svgNSi, \"tspan\")\n    tempSpanEl.setAttributeNS null, \"x\", x\n    tempSpanEl.setAttributeNS null, \"dy\", dy\n    tempTextNode = document.createTextNode(str)\n    tempSpanEl.appendChild tempTextNode\n\n    num = 0\n    while num < temp.length\n      #creating a textNode and adding it to the cell to check the width\n      tempSpanEl.firstChild.nodeValue = temp[num]\n      cell.appendChild tempSpanEl\n      #if width is bigger than maxWidth + whitespace between textBox borders and a word\n      if tempSpanEl.getComputedTextLength()+10 > maxWidth\n        tempWord = temp[num]\n        cell.removeChild(cell.firstChild)\n\n        #initializing temp variables\n        count = 1\n        start = 0\n        partWord = \"\" + tempWord[0]\n        tempArray = []\n        #check the width by increasing the word character by character\n        while count < tempWord.length\n          partWord += tempWord[count]\n          tempSpanEl.firstChild.nodeValue = partWord\n          cell.appendChild tempSpanEl\n          if tempSpanEl.getComputedTextLength()+10 > maxWidth\n            temp3.push partWord.substring(0, partWord.length-1)\n            partWord = \"\"\n            partWord += tempWord[count]\n          if count is tempWord.length-1\n            temp3.push partWord\n          while cell? and cell.hasChildNodes()\n            cell.removeChild(cell.firstChild)\n          count++\n      else\n        temp3.push temp[num]\n      while cell? and cell.hasChildNodes()\n        cell.removeChild(cell.firstChild)\n      num++\n\n    while cell? and cell.hasChildNodes()\n      cell.removeChild(cell.firstChild)\n    temp3"]}}