{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nthis.WhiteboardEllipseModel = (function(superClass) {\n  extend(WhiteboardEllipseModel, superClass);\n\n  function WhiteboardEllipseModel(paper) {\n    this.paper = paper;\n    WhiteboardEllipseModel.__super__.constructor.call(this, this.paper);\n    this.definition = [0, 0, 0, 0, \"#000\", \"0px\"];\n  }\n\n  WhiteboardEllipseModel.prototype.make = function(info) {\n    var color, thickness, x, y;\n    if ((info != null ? info.points : void 0) != null) {\n      x = info.points[0];\n      y = info.points[1];\n      color = info.color;\n      thickness = info.thickness;\n      this.obj = this.paper.ellipse(x * this.gw + this.xOffset, y * this.gh + this.yOffset, 0, 0);\n      this.obj.attr(\"stroke\", formatColor(color));\n      this.obj.attr(\"stroke-width\", zoomStroke(formatThickness(thickness)));\n      this.definition = [x, y, y, x, this.obj.attrs[\"stroke\"], this.obj.attrs[\"stroke-width\"]];\n    }\n    return this.obj;\n  };\n\n  WhiteboardEllipseModel.prototype.update = function(info) {\n    var circle, coords, r, ref, ref1, reversed, rx, ry, x1, x2, y1, y2;\n    if ((info != null ? info.points : void 0) != null) {\n      x1 = info.points[0];\n      y1 = info.points[1];\n      x2 = info.points[2];\n      y2 = info.points[3];\n      circle = info.square;\n      if (this.obj != null) {\n        if (x2 < x1) {\n          ref = [x2, x1], x1 = ref[0], x2 = ref[1];\n        }\n        if (y2 < y1) {\n          ref1 = [y2, y1], y1 = ref1[0], y2 = ref1[1];\n          reversed = true;\n        }\n        if (circle) {\n          if (reversed) {\n            y1 = y2 - (x2 - x1) * this.gw / this.gh;\n          } else {\n            y2 = y1 + (x2 - x1) * this.gw / this.gh;\n          }\n        }\n        coords = {\n          x1: x1,\n          x2: x2,\n          y1: y1,\n          y2: y2\n        };\n        rx = (x2 - x1) / 2;\n        ry = (y2 - y1) / 2;\n        r = {\n          rx: rx * this.gw,\n          ry: ry * this.gh,\n          cx: (rx + x1) * this.gw + this.xOffset,\n          cy: (ry + y1) * this.gh + this.yOffset\n        };\n        this.obj.attr(r);\n        this.definition[0] = x1;\n        this.definition[1] = y1;\n        this.definition[2] = x2;\n        return this.definition[3] = y2;\n      }\n    }\n  };\n\n  WhiteboardEllipseModel.prototype.draw = function(x1, y1, x2, y2, colour, thickness) {\n    var elip, ref, ref1, rx, ry, x, y;\n    if (x2 < x1) {\n      ref = [x2, x1], x1 = ref[0], x2 = ref[1];\n    }\n    if (y2 < y1) {\n      ref1 = [y2, y1], y1 = ref1[0], y2 = ref1[1];\n    }\n    rx = (x2 - x1) / 2;\n    ry = (y2 - y1) / 2;\n    x = (rx + x1) * this.gw + this.xOffset;\n    y = (ry + y1) * this.gh + this.yOffset;\n    elip = this.paper.ellipse(x, y, rx * this.gw, ry * this.gh);\n    elip.attr(Utils.strokeAndThickness(colour, thickness));\n    return elip;\n  };\n\n  WhiteboardEllipseModel.prototype.dragOnStart = function(x, y) {};\n\n  WhiteboardEllipseModel.prototype.dragOnMove = function(dx, dy, x, y, e) {};\n\n  WhiteboardEllipseModel.prototype.dragOnStop = function(e) {};\n\n  return WhiteboardEllipseModel;\n\n})(WhiteboardToolModel);\n","sourceMap":{"version":3,"file":"/client/whiteboard_models/whiteboard_ellipse.coffee.js","sourceRoot":"","sources":["/client/whiteboard_models/whiteboard_ellipse.coffee"],"names":[],"mappings":"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","sourcesContent":["# An ellipse in the whiteboard\nclass @WhiteboardEllipseModel extends WhiteboardToolModel\n\n    constructor: (@paper) ->\n      super @paper\n\n      # the defintion of this shape, kept so we can redraw the shape whenever needed\n      # format: top left x, top left y, bottom right x, bottom right y, stroke color, thickness\n      @definition = [0, 0, 0, 0, \"#000\", \"0px\"]\n\n    # Make an ellipse on the whiteboard\n    # @param    {[type]} x                 the x value of the top left corner\n    # @param    {[type]} y                 the y value of the top left corner\n    # @param    {string} colour        the colour of the object\n    # @param    {number} thickness the thickness of the object's line(s)\n    make: (info) ->\n      #console.log \"Whiteboard - Making ellipse: \"\n      #console.log info\n      if info?.points?\n        x = info.points[0]\n        y = info.points[1]\n        color = info.color\n        thickness = info.thickness\n\n        @obj = @paper.ellipse(x * @gw + @xOffset, y * @gh + @yOffset, 0, 0)\n        @obj.attr \"stroke\", formatColor(color)\n        @obj.attr \"stroke-width\", zoomStroke(formatThickness(thickness))\n        @definition = [x, y, y, x, @obj.attrs[\"stroke\"], @obj.attrs[\"stroke-width\"]]\n\n      @obj\n\n    # Update ellipse drawn\n    # @param    {number} x1 the x value of the top left corner in percent of current slide size\n    # @param    {number} y1 the y value of the top left corner in percent of current slide size\n    # @param    {number} x2 the x value of the bottom right corner in percent of current slide size\n    # @param    {number} y2 the y value of the bottom right corner in percent of current slide size\n    # @param    {boolean} square (draw a circle or not\n    update: (info) ->\n      #console.log info\n      if info?.points?\n        x1 = info.points[0]\n        y1 = info.points[1]\n        x2 = info.points[2]\n        y2 = info.points[3]\n\n        circle = info.square\n\n        if @obj?\n          [x1, x2] = [x2, x1] if x2 < x1\n\n          if y2 < y1\n            [y1, y2] = [y2, y1]\n            reversed = true\n\n          #if the control key is pressed then the width and height of the ellipse are equal (a circle)\n          #we calculate this by making the y2 coord equal to the y1 coord plus the width of x2-x1 and corrected for the slide size\n          if circle\n            if reversed # if reveresed, the y1 coordinate gets updated, not the y2 coordinate\n              y1 = y2 - (x2 - x1) * @gw / @gh\n            else\n              y2 = y1 + (x2 - x1) * @gw / @gh\n\n          coords =\n            x1: x1\n            x2: x2\n            y1: y1\n            y2: y2\n\n          #console.log(coords)\n\n          rx = (x2 - x1) / 2\n          ry = (y2 - y1) / 2\n\n          r =\n            rx: rx * @gw\n            ry: ry * @gh\n            cx: (rx + x1) * @gw + @xOffset\n            cy: (ry + y1) * @gh + @yOffset\n\n          @obj.attr(r)\n\n          #console.log( \"@gw: \" + @gw + \"\\n@gh: \" + @gh + \"\\n@xOffset: \" + @xOffset + \"\\n@yOffset: \" + @yOffset );\n          # we need to update all these values, specially for when shapes are drawn backwards\n          @definition[0] = x1\n          @definition[1] = y1\n          @definition[2] = x2\n          @definition[3] = y2\n\n    # Draw an ellipse on the whiteboard\n    # @param    {number} x1 the x value of the top left corner\n    # @param    {number} y1 the y value of the top left corner\n    # @param    {number} x2 the x value of the bottom right corner\n    # @param    {number} y2 the y value of the bottom right corner\n    # @param    {string} colour        the colour of the object\n    # @param    {number} thickness the thickness of the object's line(s)\n    draw: (x1, y1, x2, y2, colour, thickness) ->\n        [x1, x2] = [x2, x1] if x2 < x1\n        [y1, y2] = [y2, y1] if y2 < y1\n\n        rx = (x2 - x1) / 2\n        ry = (y2 - y1) / 2\n        x = (rx + x1) * @gw + @xOffset\n        y = (ry + y1) * @gh + @yOffset\n        elip = @paper.ellipse(x, y, rx * @gw, ry * @gh)\n        elip.attr Utils.strokeAndThickness(colour, thickness)\n        elip\n\n    # When first starting drawing the ellipse\n    # @param    {number} x the x value of cursor at the time in relation to the left side of the browser\n    # @param    {number} y the y value of cursor at the time in relation to the top of the browser\n    # TODO: moved here but not finished\n    dragOnStart: (x, y) ->\n        # sx = (@paperWidth - @gw) / 2\n        # sy = (@paperHeight - @gh) / 2\n        # # find the x and y values in relation to the whiteboard\n        # @ellipseX = (x - @containerOffsetLeft - sx + @xOffset)\n        # @ellipseY = (y - @containerOffsetTop - sy + @yOffset)\n        # globals.connection.emitMakeShape \"ellipse\",\n        #     [ @ellipseX / @paperWidth, @ellipseY / @paperHeight, @currentColour, @currentThickness ]\n\n    # When first starting to draw an ellipse\n    # @param    {number} dx the difference in the x value at the start as opposed to the x value now\n    # @param    {number} dy the difference in the y value at the start as opposed to the y value now\n    # @param    {number} x the x value of cursor at the time in relation to the left side of the browser\n    # @param    {number} y the y value of cursor at the time in relation to the top of the browser\n    # @param    {Event} e     the mouse event\n    # TODO: moved here but not finished\n    dragOnMove: (dx, dy, x, y, e) ->\n        # # if shift is pressed, draw a circle instead of ellipse\n        # dy = dx if @shiftPressed\n        # dx = dx / 2\n        # dy = dy / 2\n        # # adjust for negative values as well\n        # x = @ellipseX + dx\n        # y = @ellipseY + dy\n        # dx = (if dx < 0 then -dx else dx)\n        # dy = (if dy < 0 then -dy else dy)\n        # globals.connection.emitUpdateShape \"ellipse\",\n        #     [ x / @paperWidth, y / @paperHeight, dx / @paperWidth, dy / @paperHeight ]\n\n    # When releasing the mouse after drawing the ellipse\n    # @param    {Event} e the mouse event\n    # TODO: moved here but not finished\n    dragOnStop: (e) ->\n        # attrs = undefined\n        # attrs = @currentEllipse.attrs if @currentEllipse?\n        # if attrs?\n        #     globals.connection.emitPublishShape \"ellipse\",\n        #         [ attrs.cx / @gw, attrs.cy / @gh, attrs.rx / @gw, attrs.ry / @gh,\n        #             @currentColour, @currentThickness ]\n        # @currentEllipse = null # late updates will be blocked by this\n"]}}